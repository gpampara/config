#+TITLE: Emacs Configuration
#+AUTHOR: Gary Pamparà
#+TOC: true

This is the my emacs config as an =org-mode= configuration. The idea
of using this literate style is to keep the config as organized as
possible.

* Configure package sources

#+begin_src emacs-lisp
  (when (eval-when-compile (version< emacs-version "27"))
    (load "~/.emacs.d/early-init.el"))

  (setq package-archives
        '(("gnu" . "https://elpa.gnu.org/packages/")
          ("melpa" . "https://melpa.org/packages/")
          ("org" . "https://orgmode.org/elpa/")))
  ;;  (package-initialize)

  (unless package-archive-contents
    (package-refresh-contents))
#+end_src

* Bootstrap use-package

#+begin_src emacs-lisp
  (unless (package-installed-p 'use-package)
    (package-install 'use-package))

  (require 'use-package)
#+end_src

Always ensure that dependencies are downloaded

#+begin_src emacs-lisp
  (setq use-package-always-ensure t)
#+end_src

Define an auto-update schedule for packages

#+begin_src emacs-lisp
  (use-package auto-package-update
    :config
    (setq auto-package-update-delete-old-versions t
          auto-package-update-interval 7
          auto-package-update-prompt-before-update t)
    (auto-package-update-maybe))
#+end_src

#+begin_src emacs-lisp
  ;; (use-package use-package-ensure-system-package)
#+end_src

* no-littering

#+begin_src emacs-lisp
  (use-package no-littering
    :demand t)
#+end_src

* Shell environment variable import

Adjust shell environment variables, if needed

#+begin_src emacs-lisp
  (use-package exec-path-from-shell
    :if (memq window-system '(mac ns x))
    :config
    (setq exec-path-from-shell-variables '("PATH" "SHELL")) ;;"LANG" "LC_ALL" "LC_TYPE" "SHELL"))
    (setq exec-path-from-shell-arguments '("-l"))
    (exec-path-from-shell-initialize)
    (setenv "LANG" "en_US"))
#+end_src

* Dependencies

#+begin_src emacs-lisp
  (use-package async)
  (use-package dash)
  (use-package f)
  (use-package hl-todo)
  (use-package s)
#+end_src

* Variables

#+begin_src emacs-lisp
  (setq sentence-end-double-space nil)   ; Sentences _SHOULD_ end with only a point.
  (setq require-final-newline t)         ; Ensure there is a final newline
  (setq confirm-kill-emacs 'y-or-n-p)    ; Confirm really quit emacs
  (defalias 'yes-or-no-p 'y-or-n-p)      ; Shorten yes/no prompts to y/n

  (setq save-interprogram-paste-before-kill t
        apropos-do-all t
        mouse-yank-at-point t
        require-final-newline t
        visible-bell t
        load-prefer-newer t
        ediff-window-setup-function 'ediff-setup-windows-plain
        save-place-file (concat user-emacs-directory "places")
        backup-directory-alist `(("." . (concat user-emacs-directory
                                                 "backups"))))
#+end_src

I usually don't want tabs, if I do I can set this buffer-local to
=t=. If I just want one tab then use =C-q= (=quoted-insert=) to insert
as a literal.

#+begin_src emacs-lisp
  (setq-default indent-tabs-mode nil)
#+end_src

Use the "forward" uniquify scheme for buffer disambiguation

#+begin_src emacs-lisp
  (setq uniquify-buffer-name-style 'forward)
#+end_src

* Redefinitions

Evaluate an expression when the system is the defined value

#+begin_src emacs-lisp
  (defmacro with-system (type &rest body)
    "Evaluate BODY if `system-type' equals TYPE."
    (declare (indent defun))
    `(when (eq system-type ',type)
       ,@body))
#+end_src

On  I use ⌘ as =meta= and prefer ⌥ to do nothing so I can still
insert special characters like easily.

#+begin_src emacs-lisp
  (with-system darwin
    (setq mac-command-modifier 'meta
          mac-option-modifier 'super))
#+end_src

Disable passing various commands to the underlying  system:

#+begin_src emacs-lisp
  (with-system darwin
    (setq mac-pass-command-to-system nil))
#+end_src

Start Emacs fullscreen

#+begin_src emacs-lisp
  (with-system darwin
    (setq ns-use-native-fullscreen t)
    ;;(set-frame-parameter nil 'fullscreen 'maximized))
    (add-hook 'window-setup-hook 'toggle-frame-fullscreen t))
#+end_src

* Helper functions

Open / visit the configuration file

#+begin_src emacs-lisp
  (defun find-user-init-file ()
    (interactive)
    (find-file "~/.emacs.d/config.org"))
  ;(global-set-key (kbd "C-c e") 'config-visit)
#+end_src

Reload the configuration

#+begin_src emacs-lisp
  (defun load-user-init-file ()
    (interactive)
    (org-babel-load-file (expand-file-name "~/.emacs.d/config.org")))
  ;(global-set-key (kbd "C-c r") 'config-reload)
#+end_src

Convert text into title-case

#+begin_src emacs-lisp
  (defun xah-title-case-region-or-line (@begin @end)
    "Title case text between nearest brackets, or current line, or text selection.
  Capitalize first letter of each word, except words like {to, of, the, a, in, or, and, …}. If a word already contains cap letters such as HTTP, URL, they are left as is.

  When called in a elisp program, *begin *end are region boundaries.
  URL `http://ergoemacs.org/emacs/elisp_title_case_text.html'
  Version 2017-01-11"
    (interactive
     (if (use-region-p)
         (list (region-beginning) (region-end))
       (let (
             $p1
             $p2
             ($skipChars "^\"<>(){}[]“”‘’‹›«»「」『』【】〖〗《》〈〉〔〕"))
         (progn
           (skip-chars-backward $skipChars (line-beginning-position))
           (setq $p1 (point))
           (skip-chars-forward $skipChars (line-end-position))
           (setq $p2 (point)))
         (list $p1 $p2))))
    (let* (
           ($strPairs [
                       [" A " " a "]
                       [" And " " and "]
                       [" At " " at "]
                       [" As " " as "]
                       [" By " " by "]
                       [" Be " " be "]
                       [" Into " " into "]
                       [" In " " in "]
                       [" Is " " is "]
                       [" It " " it "]
                       [" For " " for "]
                       [" Of " " of "]
                       [" Or " " or "]
                       [" On " " on "]
                       [" Via " " via "]
                       [" The " " the "]
                       [" That " " that "]
                       [" To " " to "]
                       [" Vs " " vs "]
                       [" With " " with "]
                       [" From " " from "]
                       ["'S " "'s "]
                       ["'T " "'t "]
                       ]))
      (save-excursion
        (save-restriction
          (narrow-to-region @begin @end)
          (upcase-initials-region (point-min) (point-max))
          (let ((case-fold-search nil))
            (mapc
             (lambda ($x)
               (goto-char (point-min))
               (while
                   (search-forward (aref $x 0) nil t)
                 (replace-match (aref $x 1) "FIXEDCASE" "LITERAL")))
             $strPairs))))))
#+end_src

* Load user secrets

#+begin_src emacs-lisp
  (load "~/.emacs.d/emacs.secrets" t)
#+end_src

* Spelling settings

#+begin_src emacs-lisp
  (setq ispell-program-name "aspell")
  ;; Please note ispell-extra-args contains ACTUAL parameters passed to aspell
  ;;(setq ispell-extra-args '("-t" "--lang=en_GB" "--add-tex-command='citep op'" "--add-tex-command='citet op'"))
  (setq ispell-personal-dictionary "~/.emacs.d/personal_dictionary")
#+end_src

Flyspell correct

#+begin_src emacs-lisp
  (use-package flyspell-correct
    :after flyspell
    :bind (:map flyspell-mode-map ("C-;" . flyspell-correct-wrapper)))
#+end_src

* which-key

Which key to show a list of keys that follow a speicific key-chord

#+begin_src emacs-lisp
  (use-package which-key
    :config
    ;; Allow C-h to trigger which-key before it is done automatically
    (setq which-key-show-early-on-C-h t)
    ;; make sure which-key doesn't show normally but refreshes quickly after it is
    ;; triggered.
    (setq which-key-idle-delay 10000)
    (setq which-key-idle-secondary-delay 0.05)
    (which-key-mode 1))
#+end_src

* key bindings

#+begin_src emacs-lisp
  (use-package general
    :after which-key
    :config
    (general-override-mode 1)
  )
#+end_src

There seems to be some evidence that defining a custom key-map via
minor-mode is a good idea.

#+begin_src emacs-lisp
  (defvar gp-keys-map
    (let ((map (make-sparse-keymap)))
      (define-key map (kbd "C-c e")   'find-user-init-file)
      (define-key map (kbd "C-c r")   'load-user-init-file)

      (define-key map (kbd "C-:")     'avy-goto-char-timer)
      (define-key map (kbd "C-x C-b") 'ibuffer)
      map)
    "gp-keys-minor-mode-map")

  (define-minor-mode gp-keys
    "A minor mode that contains all my key settings to override locals"
    :init-value t
    :lighter "ok?")

  (gp-keys 1)
#+end_src

Now give priority to my custom key map:

#+begin_src emacs-lisp
  (add-hook 'after-load-functions 'my-keys-have-priority)

  (defun my-keys-have-priority (_file)
    "Try to ensure that my keybindings retain priority over other minor modes.

  Called via the `after-load-functions' special hook."
    (unless (eq (caar minor-mode-map-alist) 'gp-keys)
      (let ((mykeys (assq 'gp-keys minor-mode-map-alist)))
        (assq-delete-all 'gp-keys minor-mode-map-alist)
        (add-to-list 'minor-mode-map-alist mykeys))))
#+end_src

* avy

#+begin_src emacs-lisp
  (use-package avy
    :commands (avy-goto-char-timer))
#+end_src

* ctrlf

#+begin_src emacs-lisp
  (use-package ctrlf
    :config
    (ctrlf-mode +1))
#+end_src

* selectrum

#+begin_src emacs-lisp
  (use-package selectrum
    :config
    (setq selectrum-refine-candidates-function #'orderless-filter)
    (setq selectrum-highlight-candidates-function #'orderless-highlight-matches)
    (selectrum-mode +1))

  (use-package selectrum-prescient
    :after selectrum
    :config
    ;; to make sorting and filtering more intelligent
    (selectrum-prescient-mode +1)

    ;; to save your command history on disk, so the sorting gets more
    ;; intelligent over time
    (prescient-persist-mode +1))
#+end_src

* orderless

#+begin_src emacs-lisp
  (use-package orderless
    ;;:init (icomplete-mode)
    :custom
    (completion-styles '(orderless)))
#+end_src

* helpful

#+begin_src emacs-lisp
  (use-package helpful
    :bind
    ([remap describe-function] . helpful-callable)
    ([remap describe-command] . helpful-command)
    ([remap describe-variable] . helpful-variable)
    ([remap describe-key] . helpful-key))
#+end_src

* crux

=crux= has useful functions extracted from Emacs Prelude. Set `C-a` to
move to the first non-whitespace character on a line, and then to
toggle between that and the beginning of the line.

#+begin_src emacs-lisp
  (use-package crux
    :general
    ("C-a" 'crux-move-beginning-of-line))
#+end_src

* Delete trailing whitespace

I *never* want whitespace at the end of lines. Remove it on save.

#+begin_src emacs-lisp
 (add-hook 'before-save-hook 'delete-trailing-whitespace)
#+end_src

* PCRE in emacs

Use a plainer syntax for regexp

#+begin_src emacs-lisp
  (use-package pcre2el
    :config
    (pcre-mode))
#+end_src

* ls-lisp

On Darwin the version of =ls= does not support an option which is present in GNU coreutils' version of `ls`

#+begin_src emacs-lisp
  (when (eq system-type 'darwin)
    (setq ls-lisp-use-insert-directory-program nil)
    (require 'ls-lisp))

#+end_src

* Fonts within emacs

#+begin_src emacs-lisp
;;  (set-face-attribute 'default nil :family "Iosevka" :height 130)
#+end_src

* Terminals

** vterm

#+begin_src emacs-lisp
  (use-package vterm
    :config
    (setq vterm-max-scrollback 5000))
#+end_src

* direnv

#+begin_src emacs-lisp
  (use-package warnings)
#+end_src

#+begin_src emacs-lisp
  (use-package direnv
    :after warnings
    :config
    (add-to-list 'warning-suppress-types '(direnv))
    (direnv-mode 1))
#+end_src

* disable-mouse

To force the change in usage, just completely disable any sort of
mouse event within Emacs.

#+begin_src emacs-lisp
  (use-package disable-mouse
    :config
    (global-disable-mouse-mode))
#+end_src

* multiple-cursors

Add multiple cursor support.

 #+begin_src emacs-lisp
   (use-package multiple-cursors
      :general
      ("C-S-c C-S-c" 'mc/edit-lines)
      ("C->" 'mc/mark-next-like-this)
      ("C-<" 'mc/mark-prev-like-this)
      ("C-c C-<" 'mc/mark-all-like-this))
 #+end_src

* expand-region

Add expand-region

#+begin_src emacs-lisp
  (use-package expand-region
    :general
    ("C-=" 'er/expand-region)
    ("C-+" 'er/contract-region))
#+end_src

* magit

#+begin_src emacs-lisp
  ;;;###autoload
  (defun gp/magit-fetch-and-prune-gone-remotes ()
    (interactive)
    (magit-run-git-async "gone"))


  (use-package magit
    :demand t
    :commands git-fetch-and-prune
    :general
    ("C-x g" 'magit-status)
    :config
    ;; https://github.com/magit/magit/issues/2982#issuecomment-598493683
    (setq magit-git-executable (executable-find "git"))
    (add-hook 'git-commit-setup-hook 'git-commit-turn-on-flyspell)

    (transient-insert-suffix 'magit-fetch "p"
      '("P" "fetch, prune and remove local branches tracking 'gone' remotes" gp/magit-fetch-and-prune-gone-remotes))

    ;; http://whattheemacsd.com/setup-magit.el-01.html#comment-748135498
    ;; full screen magit-status
    (defadvice magit-status (around magit-fullscreen activate)
      (window-configuration-to-register :magit-fullscreen)
      ad-do-it
      (delete-other-windows))

    (defun magit-quit-session ()
      "Restores the previous window configuration and kills the magit buffer"
      (interactive)
      (kill-buffer)
      (jump-to-register :magit-fullscreen))

    (define-key magit-status-mode-map (kbd "q") 'magit-quit-session))
#+end_src

#+begin_src emacs-lisp
  (use-package transient
    :ensure t)
#+end_src

* ssh-agency

Manage the ssh-agent on the system by loading identities if and when required

#+begin_src emacs-lisp
  (use-package ssh-agency
    :ensure t)
#+end_src

* wgrep

#+begin_src emacs-lisp
  (use-package wgrep)
#+end_src

* ibuffer

Prefer the use of =ibuffer= instead of the default buffer list

#+begin_src emacs-lisp
  (setq ibuffer-saved-filter-groups
        '(("default"
           ("emacs-config" (or (filename . ".emacs.d")
                               (filename . "emacs-config")))
           ("Org" (or (mode . org-mode)
                      (filename . "OrgMode")))
           ("Magit" (name . "magit.*"))
           ("Help" (or (mode . help-mode)
                       (mode . Info-mode)
                       (name . ".*Apropos.*"))))))

  (add-hook 'ibuffer-mode-hook
            (lambda ()
              (ibuffer-auto-mode 1)
              (ibuffer-switch-to-saved-filter-groups "default")))

  (setq ibuffer-show-empty-filter-groups nil)

  (setq ibuffer-expert t)
#+end_src

* hydra

#+begin_src emacs-lisp
(use-package hydra)
#+end_src

* ace-window

Faster switching between windows, via =ace-window=
#+begin_src emacs-lisp
  (use-package ace-window
    :general
    ("M-o" 'ace-window)
    :config
    ;;(setq ;;aw-keys '(?a ?s ?d ?f ?j ?k ?l)
    (setq aw-dispatch-alist
          '((?x aw-delete-window " Ace - Delete Window")
            (?m aw-swap-window " Ace - Swap Window")
            (?n aw-flip-window)
            (?v aw-split-window-vert " Ace - Split Vert Window")
            (?h aw-split-window-horz " Ace - Split Horz Window")
            (?i delete-other-windows " Ace - Maximize Window")
            (?o delete-other-windows)
            (?b balance-windows)))

    (when (package-installed-p 'hydra)
      (defhydra hydra-window-size (:color red)
        "Windows size"
        ("h" shrink-window-horizontally "shrink horizontal")
        ("j" shrink-window "shrink vertical")
        ("k" enlarge-window "enlarge vertical")
        ("l" enlarge-window-horizontally "enlarge horizontal"))
      ;; (defhydra hydra-window-frame (:color red)
      ;;   "Frame"
      ;;   ("f" make-frame "new frame")
      ;;   ("x" delete-frame "delete frame"))
      ;; (defhydra hydra-window-scroll (:color red)
      ;;   "Scroll other window"
      ;;   ("n" joe-scroll-other-window "scroll")
      ;;   ("p" joe-scroll-other-window-down "scroll down"))
      (add-to-list 'aw-dispatch-alist '(?w hydra-window-size/body) t)
      ;;(add-to-list 'aw-dispatch-alist '(?o hydra-window-scroll/body) t)
      ;;(add-to-list 'aw-dispatch-alist '(?\; hydra-window-frame/body) t)
      ;;)
      (ace-window-display-mode t))
    )
#+end_src

* popup-kill-ring

Simpler interactions with the kill-ring
#+begin_src emacs-lisp
  (use-package popup-kill-ring
    :general
    ("M-y" 'popup-kill-ring))
#+end_src

* hungry-delete

Automatically delete whitespace in a sensible way with "smart" hungry delete

#+begin_src emacs-lisp
  (use-package hungry-delete
    :config
    (global-hungry-delete-mode))

  ;; (use-package smart-hungry-delete
  ;;   :bind (("<backspace>" . smart-hungry-delete-backward-char)
  ;;          ("C-d" . smart-hungry-delete-forward-char)))
#+end_src

* themes

#+begin_src emacs-lisp
  ;; (use-package modus-vivendi-theme)
  ;;(use-package gruvbox-theme)

  (use-package doom-themes
     :config
     (setq doom-themes-enable-bold t    ; if nil, bold is universally disabled
           doom-themes-enable-italic t  ; if nil, italics is universally disabled

           ;; doom-one specific settings
           ;;doom-one-brighter-modeline nil
           doom-one-brighter-comments t
           )

     ;; Corrects (and improves) org-mode's native fontification.
     (doom-themes-org-config)

     (load-theme 'doom-gruvbox t))
#+end_src

* all-the-icons

#+begin_src emacs-lisp
  (use-package all-the-icons)
#+end_src

After installation, the following needs to be run to ensure that the fonts are correctly setup:

=M-x all-the-icons-install-fonts=

* doom-modeline

#+begin_src emacs-lisp
  (use-package doom-modeline
    :init
    (doom-modeline-mode 1)
    (setq doom-modeline-buffer-file-name-style 'relative-from-project)
    ;;(setq doom-modeline-icon nil)
    ;;(setq doom-modeline-major-mode-icon nil)
    ;;(setq doom-modeline-minor-modes t)
    :custom ((doom-modeline-height 15))
    )

    ;;(load-theme 'modus-vivendi t)
    ;;(load-theme 'gruvbox-dark-hard t)
#+end_src

# Improve look and feel of titlebar on Macos. Set =ns-appearance= to
# =dark= for white title text and =nil= for black title text.

#+begin_src emacs-lisp
  ;; (with-system darwin
  ;;   (add-to-list 'default-frame-alist '(ns-transparent-titlebar . t))
  ;;   (add-to-list 'default-frame-alist '(ns-appearance . dark)))
#+end_src

* hl-line-mode

Highlight the current line.

#+begin_src emacs-lisp
;;(global-hl-line-mode 1)
#+end_src

* dashboard

Display a simple dashboard at startup
#+begin_src emacs-lisp
  (use-package dashboard
    :config
    (dashboard-setup-startup-hook)
    (setq show-week-agenda-p t)
    (setq dashboard-items '((agenda . 10)
                            (projects . 10)
                            (recents . 10)))
    (setq dashboard-set-heading-icons t)
    (setq dashboard-set-file-icons t))
    ;(setq dashboard-org-agenda-categories '("Tasks" "birthdays" "gtd")))
#+end_src

* beacon

# Add a visual inidcator when switching to a different window

#+begin_src emacs-lisp
  (use-package beacon
    :config
    (setq beacon-size 20)
    (beacon-mode 1))
#+end_src

* hippie-expand

#+begin_src emacs-lisp
  (general-define-key "M-/" 'hippie-expand)

  (setq hippie-expand-try-functions-list
        '(try-expand-dabbrev
          try-expand-dabbrev-all-buffers
          try-expand-dabbrev-from-kill
          try-complete-file-name-partially
          try-complete-file-name
          try-expand-all-abbrevs
          try-expand-list
          try-expand-line
          try-complete-lisp-symbol-partially
          try-complete-lisp-symbol))
#+end_src

* rainbow-delimeters

Some general configuration for development that is agnostic of
language.

Use parens highlighting to make reading the code a little simpler

#+begin_src emacs-lisp
  (use-package rainbow-delimiters
    :hook (prog-mode . rainbow-delimiters-mode)
    :config
    (add-hook 'TeX-update-style-hook #'rainbow-delimiters-mode)
    (set-face-attribute 'rainbow-delimiters-unmatched-face nil
                        :foreground "red"
                        :inherit 'error
                        :box t))
#+end_src

* company

Completion service using =company-mode=

#+begin_src emacs-lisp
  (use-package company
    :config
    ;;    (setq company-idle-delay 0)
    ;;    (setq company-minimum-prefix-length 3)

    (global-company-mode t))
#+end_src

* flycheck

=Flycheck= to allow for the checking of code

#+begin_src emacs-lisp
  (use-package flycheck
    ;; :diminish flycheck-mode
    :demand t
    :init
    (setq flycheck-check-syntax-automatically '(mode-enabled save)
          flycheck-checker-error-threshold 2000)
    :config
    (mapc (lambda (mode)
            (add-hook mode 'flycheck-mode))
          '(elm-mode-hook
            emacs-lisp-mode-hook
            haskell-mode-hook
            scala-mode-hook
            ))
    (add-hook 'sh-mode-hook
              (lambda ()
                (sh-set-shell "bash")
                (flycheck-select-checker 'sh-shellcheck)))
    )
#+end_src

* projectile

Project management using projectile

#+begin_src emacs-lisp
  (use-package projectile
    :diminish projectile-mode
    :bind-keymap
    ("C-c p" . projectile-command-map)
    :config
    (add-to-list 'projectile-globally-ignored-files "node_modules")
    (projectile-global-mode)
    :init
    (setq projectile-switch-project-action 'magit-status)
    (setq projectile-git-submodule-command nil) ;; Stupid submodule bullshit
    (setq projectile-completion-system 'default)
    :custom
    (projectile-indexing-method 'alien)
    )
#+end_src

* yasnippet

Snippet support

#+begin_src emacs-lisp
  (use-package yasnippet
    :config
    (use-package yasnippet-snippets)
    (yas-reload-all))
#+end_src

* Mark TODO / FIXME items

Highlight TODO / FIXME strings in buffers

#+begin_src emacs-lisp
  (use-package fic-mode
    :hook prog-mode)
#+end_src

* dumb-jump

#+begin_src emacs-lisp
  (use-package dumb-jump
    :general
    ("M-g o" 'dumb-jump-go-other-window)
    ("M-g j" 'dumb-jump-go)
    ("M-g x" 'dumb-jump-go-prefer-external)
    ("M-g z" 'dumb-jump-go-prefer-external-other-window)
    :init
    (dumb-jump-mode)
    :config
    (add-to-list 'xref-backend-functions #'dumb-jump-xref-activate)
    (setq dumb-jump-force-searcher 'ag)
    ;; Add some config for elm files
    ;; (nconc dumb-jump-language-file-exts
    ;;        '((:language "elm" :ext "elm" :agtype "elm" :rgtype "elm")))
    ;; (nconc dumb-jump-language-comments
    ;;        '((:comment "--" :language "elm")))
    ;; (nconc dumb-jump-find-rules
    ;;        ;; Rules, based off the haskell syntax
    ;;        '((:type "module" :supports ("ag" "rg") :language "elm"
    ;;                 :regex "^module\\s+JJJ\\s+"
    ;;                 :tests ("module Test exposing (exportA, exportB)"))
    ;;          (:type "type" :supports ("ag" "rg" "grep" "git-grep") :language "elm"
    ;;                 :regex "^type\\s+JJJ\\b"
    ;;                 :tests ("type Test"))
    ;;          (:type "type" :supports ("ag" "rg" "grep" "git-grep") :language "elm"
    ;;                 :regex "^type\\s+alias\\s+JJJ\\b"
    ;;                 :tests ("type alias Test"
    ;;                         "type alias Model ="))
    ;;          (:type "function" :supports ("ag" "rg" "grep" "git-grep") :language "elm"
    ;;                 :regex "^port\\s+JJJ\\b\\s*:[^:]"
    ;;                 :tests ("port requestPopup :"))
    ;;          (:type "function" :supports ("ag" "rg" "grep" "git-grep") :language "elm"
    ;;                 :regex "^\\s*JJJ\\s*:[^:].*->.*"
    ;;                 :tests ("foo : Int -> Int"))
    ;;          (:type "function" :supports ("ag" "rg" "grep" "git-grep") :language "elm"
    ;;                 :regex "^\\bJJJ(?!(\\s+::))\\s+((.|\\s)*?)=\\s+"
    ;;                 :tests ("test n = n * 2"))
    ;;          ))
    ;; ;;--regex-Elm=/^ *([[:lower:]][[:alnum:]_]+)[[:blank:]]*:[^:][^-]+$/\1/c,constant,constants/
    )
#+end_src

* Nix and nixpkg

#+begin_src emacs-lisp
  (use-package nix-mode
    :mode "\\.nix\\'")
#+end_src

* COMMENT Terminal

 #+begin_src emacs-lisp
   (defvar my-term-shell "/usr/local/bin/fish")
   (defadvice ansi-term (before force-bash)
     (interactive (list my-term-shell)))
   (ad-activate 'ansi-term)

   ;;(global-set-key (kbd "<M-return>") 'ansi-term)
 #+end_src

* org-mode

Some variables that will be needed:

#+begin_src emacs-lisp
  (setq
     org_notes (concat (getenv "HOME") "/org/roam/")
     zot_bib (concat (getenv "HOME") "/org/zotLib.bib")
     org-directory org_notes
     deft-directory org_notes
     org-roam-directory org_notes
     )
#+end_src

Deft

#+begin_src emacs-lisp
  (use-package deft
    :commands deft
    :init
    (setq deft-default-extension "org"
          ;; de-couples filename and note title:
          deft-use-filename-as-title nil
          deft-use-filter-string-for-filename t
          ;; disable auto-save
          deft-auto-save-interval -1.0
          ;; converts the filter string into a readable file-name using kebab-case:
          deft-file-naming-rules
          '((noslash . "-")
            (nospace . "-")
            (case-fn . downcase)))
    :config
    (add-to-list 'deft-extensions "tex"))
#+end_src

#+begin_src emacs-lisp
  (use-package org
    :mode (("\\.org\\'" . org-mode))
    :ensure org-plus-contrib
    :general
    ("C-c l" 'org-store-link)
    ("C-c a" 'org-agenda)
    ("C-C c" 'org-capture)
    :init
    (add-hook 'org-mode-hook #'org-indent-mode)
    (add-hook 'org-mode-hook #'flyspell-mode)
    :config
    ;;(setq org-directory "~/org")
    (setq org-log-done 'time)
    ;;(setq org-startup-indented t)
    ;;(setq org-hide-emphasis-markers t)
    ;;(setq org-log-done 'note)
    )
#+end_src

Set colours for priorities

#+begin_src emacs-lisp
  (setq org-priority-faces '((?A . (:foreground "#F0DFAF" :weight bold))
                             (?B . (:foreground "LightSteelBlue"))
                             (?C . (:foreground "OliveDrab"))))
#+end_src

* org-bullets

Improve the appearance of bullet points in Emacs:

#+begin_src emacs-lisp
  (use-package org-bullets
    :init
    ;; :config   (setq org-bullets-bullet-list '("∙"))
    (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1))))
#+end_src

* org-agenda

Define the locations of the different org files:

#+begin_src emacs-lisp
  (setq org-agenda-files (list "~/org/thesis-todo.org"
                               "~/org/gtd.org"
                               "~/org/projects.org"
                               "~/org/work.org"
                               "~/org/calendar.org"
                               "~/org/call.org"
                               "~/org/birthdays.org"))
#+end_src

* org-capture templates

#+begin_src emacs-lisp
  (setq org-capture-templates
        '(("T" "Thesis todo" entry
           (file+headline "~/org/thesis-todo.org" "Thesis Tasks")
           "* TODO %?\n  %i\n  %a")
          ("t" "Todo" entry
           (file+headline "~/org/gtd.org" "Tasks")
           "* TODO %?\n  %i\n  %a")
          ("p" "Project Todo" entry
           (file+headline "~/org/projects.org" "Tasks")
           "* TODO %?\n  %i\n  %a")
          ("w" "Work Todo" entry
           (file+headline "~/org/work.org" "Tasks")
           "* TODO %?\n  %i\n  %a")
          ("c" "Call someone" entry
           (file+headline "~/org/call.org" "To call")
           "* TODO %?\n  %i\n")
          ))
#+end_src

* COMMENT org-beamer

#+begin_src emacs-lisp
(eval-after-load "ox-latex"

  ;; update the list of LaTeX classes and associated header (encoding, etc.)
  ;; and structure
  '(add-to-list 'org-latex-classes
                `("beamer"
                  ,(concat "\\documentclass[presentation]{beamer}\n"
                           "[DEFAULT-PACKAGES]"
                           "[PACKAGES]"
                           "[EXTRA]\n")
                  ("\\section{%s}" . "\\section*{%s}")
                  ("\\subsection{%s}" . "\\subsection*{%s}")
                  ("\\subsubsection{%s}" . "\\subsubsection*{%s}"))))
#+end_src

* org-noter

#+begin_src emacs-lisp
  (use-package org-noter
    :after (org pdf-view)
    :config
    (setq
       ;; The WM can handle splits
       org-noter-notes-window-location 'other-frame
       ;; Please stop opening frames
       org-noter-always-create-frame nil
       ;; I want to see the whole file
       org-noter-hide-other nil
       ;; Everything is relative to the main notes file
       org-noter-notes-search-path (list org_notes)
       org-noter-default-notes-file-names '("notes.org")
       org-noter-separate-notes-from-heading t))
#+end_src

* org-roam

#+begin_src emacs-lisp
  (use-package org-roam
    :hook
    (after-init . org-roam-mode)
    :bind (:map org-roam-mode-map
                (("C-c n l" . org-roam)
                 ("C-c n f" . org-roam-find-file)
                 ("C-c n g" . org-roam-show-graph)
                 ("C-c n c" . org-roam-capture))
                :map org-mode-map
                (("C-c n i" . org-roam-insert)
                 ("C-c n b" . org-roam-switch-to-buffer)))
    :config
    (setq org-roam-list-files-commands '(elisp)) ; Use elisp to recurse the current directory
    ;;(setq org-roam-directory "/Users/gpampara/org/roam/")

    ;; redefine org-roam--list-files based on some debugging with jethro on the org-roam slack
    ;; (defun org-roam--list-files (dir)
  ;;     "Return all Org-roam files located recursively within DIR.
  ;; Use external shell commands if defined in `org-roam-list-files-commands'."
  ;;     (let (path exe)
  ;;       (cl-dolist (cmd org-roam-list-files-commands)
  ;;         (pcase cmd
  ;;         (`(,e . ,path)
  ;;          (setq path (executable-find path)
  ;;                exe  (symbol-name e)))
  ;;         ((pred symbolp)
  ;;          (setq path (executable-find (symbol-name cmd))
  ;;                exe (symbol-name cmd)))
  ;;         (wrong-type
  ;;          (signal 'wrong-type-argument
  ;;                  `((consp symbolp)
  ;;                    ,wrong-type))))
  ;;         (when path (cl-return)))
  ;;       (if-let* ((files (when path
  ;;                          (let ((fn (intern (concat "org-roam--list-files-" exe))))
  ;;                            (unless (fboundp fn) (user-error "%s is not an implemented search method" fn))
  ;;                            (funcall fn path (format "\"%s\"" dir)))))
  ;;                 (files (mapcar #'ansi-color-filter-apply files)) ; strip ansi codes
  ;;                 (files (seq-filter #'org-roam--org-roam-file-p files))
  ;;                 (files (mapcar #'expand-file-name files))) ; canonicalize names
  ;;           files
  ;;         (org-roam--list-files-elisp dir))))
    )

  ;;    (use-package org-roam
  ;;;;      :hook
  ;;      (after-init . org-roam-mode)
  ;;      :general
  ;;      (:prefix "C-c n"
  ;;               "f" 'org-roam-find-file
  ;;               "l" 'org-roam
  ;;               "b" 'org-roam-switch-to-buffer
  ;;               "g" 'org-roam-graph
  ;;               "i" 'org-roam-insert)
  ;;      :init
  ;;      (executable-find "sqlite3")
  ;;      (setq org-roam-directory "/Users/gpampara/org/roam"))
  ;;      ;;(org-roam-graph-executable "/usr/local/bin/dot"))
#+end_src

Completion with =company-mode=

#+begin_src emacs-lisp
  (use-package company-org-roam
    :after org-roam
    :config
    (push 'company-org-roam company-backends))
#+end_src

* COMMENT org-roam-bibtex

#+begin_src emacs-lisp
  (use-package org-roam-bibtex
    :after (org-roam)
    :hook (org-roam-mode . org-roam-bibtex-mode)
    :config
    (setq orb-preformat-keywords
     '("=key=" "title" "url" "file" "author-or-editor" "keywords"))
    (setq orb-templates
          '(("r" "ref" plain (function org-roam-capture--get-point)
             ""
             :file-name "${slug}"
             :head "#+TITLE: ${=key=}: ${title}\n#+ROAM_KEY: ${ref}
  - tags ::
  - keywords :: ${keywords}
  \n* ${title}\n  :PROPERTIES:\n  :Custom_ID: ${=key=}\n  :URL: ${url}\n  :AUTHOR: ${author-or-editor}\n  :NOTER_DOCUMENT: %(orb-process-file-field \"${=key=}\")\n  :NOTER_PAGE: \n  :END:\n\n"
             :unnarrowed t))))
#+end_src

* org-journal

For fleeting day to day notes

#+begin_src emacs-lisp
  (use-package org-journal
    :bind
    ("C-c n j" . org-journal-new-entry)
    :custom
    (org-journal-dir "/Users/gpampara/org/roam/")
    ;;(org-journal-date-prefix "* ")
    (org-journal-file-format "%Y-%m-%d.org")
    (org-journal-date-format "%A, %d %B %Y")

    :config
    (setq org-journal-enable-agenda-integration t
          org-journal-file-type 'monthly)

    (defun org-journal-file-header-func (time)
      "Custom function to create journal header."
      (concat
       (pcase org-journal-file-type
         (`daily "#+TITLE: Daily Journal\n#+STARTUP: showeverything")
         (`weekly "#+TITLE: Weekly Journal\n#+STARTUP: folded")
         (`monthly "#+TITLE: Monthly Journal\n#+STARTUP: folded")
         (`yearly "#+TITLE: Yearly Journal\n#+STARTUP: folded"))))

    (setq org-journal-file-header 'org-journal-file-header-func)
    )
#+end_src

* Writing

=writegood-mode= highlights bad words, weasels etc. Also has functions
to calculate readability of writing.

#+begin_src emacs-lisp
  (use-package writegood-mode
  ;;:bind ("C-c g" . writegood-mode)
    :init
    (add-hook 'TeX-update-style-hook #'writegood-mode)
    :config
    (add-to-list 'writegood-weasel-words "actionable"))
#+end_src

Add =langtool= as an additional tool to use

#+begin_src emacs-lisp
  (use-package langtool
    :config
    (setq langtool-language-tool-jar "/usr/local/Cellar/languagetool/4.3/libexec/languagetool-commandline.jar"))
#+end_src

#+begin_src emacs-lisp
  (use-package writeroom-mode
    :bind (:map writeroom-mode-map
                ("C-s-," . writeroom-decrease-width)
                ("C-s-." . writeroom-increase-width)
                ("C-s-=" . writeroom-adjust-width))
    :config
    (setq writeroom-width 120)
    (advice-add 'text-scale-adjust :after #'visual-fill-column-adjust))

    (add-hook 'LaTeX-mode-hook 'writeroom-mode)
    ;;(add-hook 'LaTeX-mode-hook 'adaptive-wrap-prefix-mode)
    (add-hook 'LaTeX-mode-hook 'visual-line-mode)
#+end_src

** Thesaurus and dictionary

#+begin_src emacs-lisp
  (with-system darwin
    (use-package osx-dictionary
      :bind (("M-\\" . osx-dictionary-search-pointer))))
#+end_src

* Language Server (LSP)

#+begin_src emacs-lisp
    (use-package lsp-mode
      :commands (lsp lsp-deferred)
      :hook
      ((elm-mode . lsp-deferred)
       (scala-mode . lsp-deferred)
       )
      :config
      (setq lsp-diagnostics-provider :flycheck)
      (lsp-enable-which-key-integration t)
      :custom
      (lsp-enable-xref t))

    (use-package lsp-ui
      :config
      (setq lsp-ui-doc-delay 2))
    ;;(use-package lsp-ui :commands lsp-ui-mode)
        ;; :after lsp-mode
        ;; :diminish
        ;; :commands lsp-ui-mode
        ;; :custom-face
        ;; (lsp-ui-doc-background ((t (:background nil))))
        ;; (lsp-ui-doc-header ((t (:inherit (font-lock-string-face italic)))))
        ;; :custom
        ;; (lsp-ui-doc-enable t)
        ;; (lsp-ui-doc-header t)
        ;; (lsp-ui-doc-include-signature t)
        ;; (lsp-ui-doc-position 'top)
        ;; (lsp-ui-doc-border (face-foreground 'default))
        ;; (lsp-ui-sideline-enable nil)
        ;; (lsp-ui-sideline-ignore-duplicate t)
        ;; (lsp-ui-sideline-show-code-actions nil)
        ;; :config
        ;; ;; Use lsp-ui-doc-webkit only in GUI
        ;; (setq lsp-ui-doc-use-webkit t)
        ;; ;; WORKAROUND Hide mode-line of the lsp-ui-imenu buffer
        ;; ;; https://github.com/emacs-lsp/lsp-ui/issues/243
        ;; (defadvice lsp-ui-imenu (after hide-lsp-ui-imenu-mode-line activate)
        ;;   (setq mode-line-format nil))
        ;; (defun lsp--send-did-save-p () t))


    ;; Add metals backend for lsp-mode
    (use-package lsp-metals
      :config (setq lsp-metals-treeview-show-when-views-received t))

    ;; Use the Debug Adapter Protocol for running tests and debugging
    (use-package posframe
      ;; Posframe is a pop-up tool that must be manually installed for dap-mode
      )
    (use-package dap-mode
      :hook
      (lsp-mode . dap-mode)
      (lsp-mode . dap-ui-mode)
      )
#+end_src

** Debug Adapter Protocol (DAP)

#+begin_src emacs-lisp
  (use-package dap-mode)
#+end_src

* auto-fill comments

#+begin_src emacs-lisp
  (add-hook 'prog-mode (lambda ()
                         ((auto-fill-mode 1)
                          (setq comment-auto-fill-only-comments t))))
#+end_src

* Javascript and "friends"

#+begin_src emacs-lisp
  (use-package add-node-modules-path)
#+end_src

#+begin_src emacs-lisp
  ;;   (use-package js2-mode
  ;;     :after (add-node-modules-path)
  ;;     :interpreter (("node" . js2-mode))
  ;; ;;    :bind (:map js2-mode-map ("C-c C-p" . js2-print-json-path))
  ;;     :mode "\\.\\(js\\|json\\)$"
  ;;     :config
  ;;     (add-hook 'js-mode-hook 'js2-minor-mode)
  ;;     (eval-after-load 'js2-mode '(add-hook 'js2-mode-hook 'add-node-modules-path))
  ;;     (flycheck-add-mode 'javascript-eslint 'js2-mode)
  ;;     (setq js2-basic-offset 2
  ;;           js2-highlight-level 3
  ;;           js2-mode-show-parse-errors nil
  ;;           js2-mode-show-strict-warnings nil))
#+end_src

#+begin_src emacs-lisp
  (use-package prettier-js
    :after (js-mode add-node-modules-path)
    :hook (js-mode . prettier-js-mode))
#+end_src

* coffeescript

#+begin_src emacs-lisp
  (use-package coffee-mode
    :mode (("\\.coffee\\'" . coffee-mode)))
#+end_src

* Elm

Add =elm-mode= configuration for editing of elm buffers.

#+begin_src emacs-lisp
  (use-package elm-mode
    :mode "\\.elm\\'"
    :init
    (add-to-list 'company-backends 'company-elm)
    :config
    ;;(add-hook 'after-init-hook #'global-flycheck-mode)
    (add-hook 'elm-mode-hook #'elm-format-on-save-mode))
#+end_src

* Haskell

Some _very_ basic Haskell config

#+begin_src emacs-lisp
  (defun fix-imports ()
    "Fixes imports."
    (interactive)
    (sort-lines nil (region-beginning) (region-end))
    (align-regexp (region-beginning) (region-end) "\\(\\s-*\\)#-"))

  (use-package haskell-mode
    :mode "\\.hs\\'")
#+end_src

* Poly-mode

Define polymode to allow multiple modes in a single buffer. Handy for
=knitr= and friends

#+begin_src emacs-lisp
  (use-package poly-R
    :ensure t)
#+end_src

#+begin_src emacs-lisp
  (use-package poly-noweb
    :ensure t)
#+end_src

#+begin_src emacs-lisp
  (use-package polymode
    :mode
    (("\\.Rnw" . poly-noweb+R-mode)
     ("\\.Rtex" . poly-noweb+R-mode)))
#+end_src

* LaTeX

Setup AUCTex for some nice LaTeX support in emacs. This workflow is
centered around using =latexmk= as the build tool and that the LaTeX
project is version controlled in git.

From the project specific =.latexmkrc= we can then determine relative
pathing for files to correctly allow for the automatic setting of the
=TeX-master= variable, removing the need to spoil the source files
themselves with local config comment strings.

#+begin_src emacs-lisp
  (defun ales/fill-paragraph (&optional P)
    "When called with prefix argument call `fill-paragraph'.
  Otherwise split the current paragraph into one sentence per line.
  Optional argument P Dunno?"
    (interactive "P")
    (if (not P)
        (save-excursion
          (let ((fill-column 12345678)) ;; relies on dynamic binding
            (fill-paragraph) ;; this will not work correctly if the paragraph is
                             ;; longer than 12345678 characters (in which case the
                             ;; file must be at least 12MB long. This is unlikely.)
            (let ((end (save-excursion
                         (forward-paragraph 1)
                         (backward-sentence)
                         (point-marker))))  ;; remember where to stop
              (beginning-of-line)
              (while (progn (forward-sentence)
                            (<= (point) (marker-position end)))
                (just-one-space) ;; leaves only one space, point is after it
                (delete-char -1) ;; delete the space
                (newline)        ;; and insert a newline
                (LaTeX-indent-line) ;; I only use this in combination with late, so this makes sense
                ))))
      ;; otherwise do ordinary fill paragraph
      (fill-paragraph P)))


  (use-package tex-site
    :ensure auctex
    :after (tex latex)
    :defer t
    :mode
    (("\\.tex\\'" . LaTeX-mode))
    :commands (latex-mode LaTeX-mode plain-tex-mode)
    :general
    (LaTeX-mode-map "M-q" 'ales/fill-paragraph)
    ;; (add-hook 'LaTeX-mode-hook (lambda ()
    ;;                              (setq TeX-master (relative-master (buffer-file-name)))
    ;;                              (add-to-list 'TeX-command-list '("Make" "make" TeX-run-TeX nil t))
    ;;                              (add-to-list 'TeX-command-list
    ;;                                           '("custom" "something"
    ;;                                             (lambda (name command file)
    ;;                                               (message name command file)
    ;;                                               (let ((TeX-save-query nil)
    ;;                                                     (TeX-process-asynchronous t)
    ;;                                                     (TeX-error-overview-open-after-TeX-run t)
    ;;                                                     (master-file (TeX-master-file))
    ;;                                                     (process (TeX-command-menu "Make")))
    ;;                                                 (set-process-sentinel process 'reload-after-TeX-complete)))
    ;;                                             nil t)
    ;;                                           )
    ;;                              ))

    ;; (add-hook 'outline-minor-mode-hook
    ;;           (lambda ()
    ;;             (define-key outline-minor-mode-map ["\C-o"] 'outline-cycle)))
    :config
    (setq-default TeX-master nil)
    (setq TeX-auto-save t
          TeX-parse-self t
          TeX-save-query nil
          ;;TeX-command-force "custom"
          TeX-PDF-mode t
          reftex-plug-into-AUCTeX t
          reftex-use-external-file-finders t
          LaTeX-csquotes-open-quote "\\enquote{"
          LaTeX-csquotes-close-quote "}"
          reftex-bibliography-commands '("bibliography" "nobibliography" "addbibresource") ;; Make reftex try play nicer with biblatex
          reftex-cite-format 'natbib)

    (add-hook 'LaTeX-mode-hook 'LaTeX-preview-setup)
    (add-hook 'LaTeX-mode-hook 'flyspell-mode)
    (add-hook 'LaTeX-mode-hook 'turn-on-reftex)
    (add-hook 'LaTeX-mode-hook 'LaTeX-math-mode)
    (add-hook 'LaTeX-mode-hook 'visual-line-mode)

    ;; Highlight the current line which works really well for writing
    (add-hook 'LaTeX-mode-hook 'hl-line-mode)

    ;; to use pdfview with auctex
    ;;(add-hook 'LaTeX-mode-hook 'pdf-tools-install)

    ;; to use pdfview with auctex
    ;; (setq TeX-view-program-selection '((output-pdf "pdf-tools"))
    ;;       TeX-source-correlate-start-server t)
    ;; (setq TeX-view-program-list '(("pdf-tools" "TeX-pdf-tools-sync-view")))

    ;; Fancy verbatim config for code blocks in thesis
    (add-to-list 'LaTeX-verbatim-environments "code")
    (add-to-list 'LaTeX-indent-environment-list '("code" current-indentation))

    ;; Spelling
    (setq ispell-tex-skip-alists
          '((
             ;;("%\\[" . "%\\]") ; AMStex block comment...
             ;; All the standard LaTeX keywords from L. Lamport's guide:
             ;; \cite, \hspace, \hspace*, \hyphenation, \include, \includeonly
             ;; \input, \label, \nocite, \rule (in ispell - rest included here)
             ("[^\\]\\$" . "[^\\]\\$") ;; For inline math. e.g., $\mathbf{\hat{y}}$
             ("_\\\\{" . "\\\\}") ;; subscripts need to be excluded explicitly??
             ("\\\\addcontentsline"              ispell-tex-arg-end 2)
             ("\\\\add\\(tocontents\\|vspace\\)" ispell-tex-arg-end)
             ("\\\\\\([aA]lph\\|arabic\\)"       ispell-tex-arg-end)
             ("\\\\author"                       ispell-tex-arg-end)
             ;; New regexps here --- kjh
             ("\\\\\\(text\\|paren\\)cite"       ispell-tex-arg-end)
             ("\\\\\\(c\\|C\\)ite\\(t\\|p\\|year\\|yearpar\\|author\\)" ispell-tex-arg-end)
             ("\\\\bibliographystyle"            ispell-tex-arg-end)
             ("\\\\\\(g\\|G\\)\\(l\\|L\\)\\(s\\|S\\)\\(pl\\)?"         ispell-tex-arg-end)
             ("\\\\\\(c\\|v\\|C\\|V\\)ref"                 ispell-tex-arg-end)
             ("\\\\label"                        ispell-tex-arg-end)
             ("\\\\makebox"                      ispell-tex-arg-end 0)
             ("\\\\e?psfig"                      ispell-tex-arg-end)
             ("\\\\\\(g\\|G\\)\\(l\\|L\\)\\(s\\|S\\)\\(pl\\)"   ispell-tex-arg-end)
             ("\\\\document\\(class\\|style\\)" .
              "\\\\begin[ \t\n]*{[ \t\n]*document[ \t\n]*}"))
            (
             ;; delimited with \begin.  In ispell: displaymath, eqnarray,
             ;; eqnarray*, equation, minipage, picture, tabular,
             ;; tabular* (ispell)
             ("\\(figure\\|table\\)\\*?"         ispell-tex-arg-end 0)
             ;;("\\(equation\\|eqnarray\\)\\*?"     ispell-tex-arg-end 0)
             ("equation"                         ispell-tex-arg-end 0)
             ;;("algorithm"                        ispell-tex-arg-end 0)
             ("list"                             ispell-tex-arg-end 2)
             ("program" . "\\\\end[ \t\n]*{[ \t\n]*program[ \t\n]*}")
             ("tikzpicture" . "\\\\end[ \t\n]*{[ \t\n]*tikzpicture[ \t\n]*}")
             ("verbatim\\*?"."\\\\end[ \t\n]*{[ \t\n]*verbatim\\*?[ \t\n]*}")
             ("lstlisting\\*?"."\\\\end[ \t\n]*{[ \t\n]*lstlisting\\*?[ \t\n]*}"))))
    )
#+end_src

Now add =pdf-tools= for nicer PDF interactions

#+begin_src emacs-lisp
  ;; (use-package pdf-tools
  ;;   :defer t
  ;;   :magic ("%PDF" . pdf-view-mode)
  ;;   :config
  ;;   (with-system darwin
  ;;     ;; https://github.com/politza/pdf-tools/issues/480#issuecomment-473707355
  ;;     (setenv "PKG_CONFIG_PATH" "/usr/local/lib/pkgconfig:/usr/local/Cellar/libffi/3.2.1/lib/pkgconfig"))
  ;;   ;; initialise
  ;;   (pdf-tools-install)
  ;;   ;; open pdfs scaled to fit page
  ;;   (setq-default pdf-view-display-size 'fit-page)
  ;;   ;; automatically annotate highlights
  ;;   (setq pdf-annot-activate-created-annotations t)
  ;;   ;; use normal isearch
  ;;   (define-key pdf-view-mode-map (kbd "C-s") 'isearch-forward))
#+end_src

* Scala

Use =scala-mode= for scala syntax highlighting

#+begin_src emacs-lisp
  (use-package scala-mode
    :mode "\\.s\\(cala\\|bt\\)$")

  (use-package sbt-mode
    :commands sbt-start sbt-command
    :config
    ;; WORKAROUND: https://github.com/ensime/emacs-sbt-mode/issues/31
    ;; allows using SPACE when in the minibuffer
    (substitute-key-definition
     'minibuffer-complete-word
     'self-insert-command
     minibuffer-local-completion-map)
    ;; sbt-supershell kills sbt-mode:  https://github.com/hvesalai/emacs-sbt-mode/issues/152
    (setq sbt:program-options '("-Dsbt.supershell=false"))
    )
#+end_src

* Dhall

#+begin_src emacs-lisp
  (use-package dhall-mode
    :mode ("\\.dhall\\'"))
#+end_src

* YAML

#+begin_src emacs-lisp
  (use-package yaml-mode
    :mode ("\\.y[a?]ml\\'"))
#+end_src

* ledger-mode

#+begin_src emacs-lisp
  (defun ledger-find-file ()
    (interactive)
    (find-file "~/ledger/ledger-2020.ledger"))

  (use-package ledger-mode
    :mode "\\.ledger\\'"
    :general
    (:prefix "C-c C-l"
             "f" 'ledger-find-file)
    :init
    (setq ledger-clear-whole-transactions 1)
    :config
    (setq ledger-reconcile-default-commodity "R"))
#+end_src

Flycheck-ledger

#+begin_src emacs-lisp
  (use-package flycheck-ledger
    :after flycheck)
#+end_src

* rg.el

~rg.rl~ is a great alternative to /counsel-rg/ that was the goto for
this config. this package is very flexible and far more standalone
than the alternatives whilst being very easy to use.

This is a great package and makes searching for things far more simple.

#+begin_src emacs-lisp
  (use-package rg
    :after wgrep
    :config
    (rg-enable-default-bindings)

    (rg-define-search gp/rg-vc-or-dir
      :query ask
      :format regexp
      :files "everything"
      :dir (let ((vc (projectile-project-root)))
             (if vc
                 vc                  ; search root project directory
               default-directory))   ; or from the current directory
      :confirm prefix
      :flags ("--hidden --smart-case -g !.git -g '!**/node_modules/**'")
      :menu ("Custom" "k" "Project from root"))
    )
#+end_src

* bazel

#+begin_src emacs-lisp
  (use-package bazel-mode)
#+end_src
