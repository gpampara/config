#+TITLE: Emacs Config
#+AUTHOR: Gary Pamparà
#+TOC: true

This is the my emacs config as an =org-mode= configuration. The idea
of using this literate style is to keep the config as organized as
possible.

* Dependencies

#+BEGIN_SRC emacs-lisp
  (use-package async)
  (use-package dash)
  (use-package f)
  (use-package hl-todo)
  (use-package s)
#+END_SRC

* Variables

* Redefinitions

* Helper functions

Evaluate an expression when the system is the defined value

#+BEGIN_SRC emacs-lisp
  (defmacro with-system (type &rest body)
    "Evaluate BODY if `system-type' equals TYPE."
    (declare (indent defun))
    `(when (eq system-type ',type)
       ,@body))
#+END_SRC

Open / visit the configuration file

#+BEGIN_SRC emacs-lisp
  (defun config-visit ()
    (interactive)
    (find-file "~/.emacs.d/config.org"))
  (global-set-key (kbd "C-c e") 'config-visit)
#+END_SRC

Reload the configuration

#+BEGIN_SRC emacs-lisp
  (defun config-reload ()
    (interactive)
    (org-babel-load-file (expand-file-name "~/.emacs.d/config.org")))
  (global-set-key (kbd "C-c r") 'config-reload)
#+END_SRC

* Configure package sources

#+BEGIN_SRC emacs-lisp
  ;; Correct a bug that is in Emacs <= 26.2
  ;; https://debbugs.gnu.org/cgi/bugreport.cgi?bug=34341#19
  ;;(setq gnutls-algorithm-priority "NORMAL:-VERS-TLS1.3")

  (let* ((no-ssl (and (memq system-type '(windows-nt ms-dos))
                      (not (gnutls-available-p))))
         (proto (if no-ssl "http" "https")))
    ;; Comment/uncomment these two lines to enable/disable MELPA and MELPA Stable as desired
    (add-to-list 'package-archives (cons "melpa" (concat proto "://melpa.org/packages/")) t)
    ;;(add-to-list 'package-archives (cons "melpa-stable" (concat proto "://stable.melpa.org/packages/")) t)
    (when (< emacs-major-version 24)
      ;; For important compatibility libraries like cl-lib
      (add-to-list 'package-archives '("gnu" . (concat proto "://elpa.gnu.org/packages/")))))

  (when (eval-when-compile (version< emacs-version "27"))
    (load "~/.emacs.d/early-init.el")
    (package-initialize))

  (setq package-archives
        '(("gnu" . "https://elpa.gnu.org/packages/")
          ("melpa" . "https://melpa.org/packages/")))

  (setq package-enable-at-startup nil)
#+END_SRC

# ** Benchmark setup
# `benchmark-init` records the startup time by package so that we can
# debug problems. The package only records after it has been loaded, so
# we put it as early as possible.
#
# #+BEGIN_SRC emacs-lisp
# (use-package benchmark-init
#   :config
#   ;; To disable collection of benchmark data after init is done.
#   (add-hook 'after-init-hook 'benchmark-init/deactivate))
#
# (add-hook 'after-init-hook
#   (lambda () (message "loaded in %s" (emacs-init-time))))
# #+END_SRC

* Bootstrap use-package

#+BEGIN_SRC emacs-lisp
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))
#+END_SRC

Always ensure that dependencies are downloaded

#+BEGIN_SRC emacs-lisp
  (setq use-package-always-ensure t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package auto-package-update
    :config
    (setq auto-package-update-delete-old-versions t
          auto-package-update-interval 7
          auto-package-update-prompt-before-update t)
    (auto-package-update-maybe))
#+END_SRC

* Load custom settings

#+BEGIN_SRC emacs-lisp
  (setq custom-file "~/.emacs.d/custom-settings.el")
  (load custom-file t)
#+END_SRC

* Load secrets

#+BEGIN_SRC emacs-lisp
  (load "~/.emacs.d/emacs.secrets" t)
#+END_SRC

* Interface
** Basics

=crux= has useful functions extracted from Emacs Prelude. Set `C-a` to
move to the first non-whitespace character on a line, and then to
toggle between that and the beginning of the line.

#+BEGIN_SRC emacs-lisp
(use-package crux
    :bind (("C-a" . crux-move-beginning-of-line)))
#+END_SRC

I *never* want whitespace at the end of lines. Remove it on save.

#+BEGIN_SRC emacs-lisp
 (add-hook 'before-save-hook 'delete-trailing-whitespace)
#+END_SRC

Also, having a newline at the end of the file is a "good" thing:

 #+BEGIN_SRC emacs-lisp
   (setq require-final-newline t)
 #+END_SRC


Don't display the help screen

#+BEGIN_SRC emacs-lisp
  (setq inhibit-startup-screen t)
#+END_SRC

On  I use ⌘ as =meta= and prefer ⌥ to do nothing so I can still
insert special characters like easily.

#+BEGIN_SRC emacs-lisp
  (with-system darwin
    (setq mac-command-modifier 'meta
          mac-option-modifier 'super))
#+END_SRC

Disable passing various commands to the underlying  system:

#+BEGIN_SRC emacs-lisp
  (with-system darwin
    (setq mac-pass-command-to-system nil))
#+END_SRC

# Some fancy  composition:
#
#+BEGIN_SRC emacs-lisp
  ;; (with-system darwin
  ;;   (if (fboundp 'mac-auto-operator-composition-mode)
  ;;       (mac-auto-operator-composition-mode t)))
#+END_SRC

Make the =yes or no= prompts shorter.

#+BEGIN_SRC emacs-lisp
  (defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC

Prevent accidental quit emacs

#+BEGIN_SRC emacs-lisp
  (setq confirm-kill-emacs 'y-or-n-p)
#+END_SRC

Start emacs fullscreen

#+BEGIN_SRC emacs-lisp
  (with-system darwin
    (setq ns-use-native-fullscreen t)
    ;;(set-frame-parameter nil 'fullscreen 'maximized))
    (add-hook 'window-setup-hook 'toggle-frame-fullscreen t))
#+END_SRC

I usually don't want tabs, if I do I can set this buffer-local to
=t=. If I just want one tab then use =C-q= (=quoted-insert=) to insert
as a literal.

#+BEGIN_SRC emacs-lisp
  (setq-default indent-tabs-mode nil)
#+END_SRC

I'm not a fan of the backup and autosave functionality of emacs as
most of my work will be in a repository anyway.

#+BEGIN_SRC emacs-lisp
  (setq make-backup-files nil)
  (setq auto-save-default nil)

  (setq save-interprogram-paste-before-kill t
        apropos-do-all t
        mouse-yank-at-point t
        require-final-newline t
        visible-bell t
        load-prefer-newer t
        ediff-window-setup-function 'ediff-setup-windows-plain
        save-place-file (concat user-emacs-directory "places")
        create-lockfiles nil
        backup-directory-alist `(("." . (concat user-emacs-directory
                                                 "backups"))))
#+END_SRC

Use a plainer syntax for regexp

#+BEGIN_SRC emacs-lisp
  (use-package pcre2el
    :config
    (pcre-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (when (eq system-type 'darwin)
    (require 'ls-lisp)
    (setq ls-lisp-use-insert-directory-program nil))
#+END_SRC

Some system config for encoding

#+BEGIN_SRC emacs-lisp
  (set-language-environment "UTF-8")
  (set-default-coding-systems 'utf-8)
#+END_SRC

** Font

#+BEGIN_SRC emacs-lisp
  (set-face-attribute 'default nil :family "Iosevka" :height 130)
#+END_SRC

* Adjust shell variables

Adjust shell environment variables, if needed

#+BEGIN_SRC emacs-lisp
  (use-package exec-path-from-shell
    :if (memq window-system '(mac ns x))
    :config
    (setq exec-path-from-shell-variables '("PATH" "SHELL")) ;;"LANG" "LC_ALL" "LC_TYPE" "SHELL"))
    (setq exec-path-from-shell-arguments '("-l"))
    (exec-path-from-shell-initialize)
    (setenv "LANG" "en_US"))
#+END_SRC

* Direnv

#+BEGIN_SRC emacs-lisp
  (use-package direnv
    :config
    (direnv-mode)
    (defun direnv--export (directory)
      "Call direnv for DIRECTORY and return the parsed result."
      (unless direnv--installed
        (setq direnv--installed (direnv--detect)))
      (unless direnv--installed
        (user-error "Could not find the direnv executable. Is exec-path correct?"))
      (let ((environment process-environment)
            (stderr-tempfile (make-temp-file "direnv-stderr"))) ;; call-process needs a file for stderr output
        (unwind-protect
            (with-current-buffer (get-buffer-create direnv--output-buffer-name)
              (erase-buffer)
              (let* ((default-directory directory)
                     (process-environment environment)
                     (exit-code (call-process "direnv" nil `(t ,stderr-tempfile) nil "export" "json"))
                     (json-key-type 'string))
                (prog1
                    (unless (zerop (buffer-size))
                      (goto-char (point-max))
                      (re-search-backward "^{")
                      (json-read-object))
                  (unless (zerop (direnv--file-size stderr-tempfile))
                    (goto-char (point-max))
                    (unless (zerop (buffer-size))
                      (insert "\n\n"))
                    (insert-file-contents stderr-tempfile)))))
          (delete-file stderr-tempfile))))
    )
#+END_SRC

* Navigation

To force the change in usage, just completely disable any sort of
mouse event within Emacs.

#+BEGIN_SRC emacs-lisp
  ;; (use-package disable-mouse
  ;;   :config
  ;;   (global-disable-mouse-mode))
#+END_SRC

Simplified window movement

#+BEGIN_SRC emacs-lisp
  (use-package windmove
    :config
    (global-set-key (kbd "<s-left>")  'windmove-left)  ;; Ctrl+Cmd+left go to left window
    (global-set-key (kbd "<s-right>") 'windmove-right) ;; Ctrl+Cmd+right go to right window
    (global-set-key (kbd "<s-up>")    'windmove-up)    ;; Ctrl+Cmd+up go to upper window
    (global-set-key (kbd "<s-down>")  'windmove-down)  ;; Ctrl+Cmd+down go to down window
  )
#+END_SRC
* Multiple cursors

Add multiple cursor support.

 #+BEGIN_SRC emacs-lisp
 (use-package multiple-cursors
    :bind (("C-S-c C-S-c" . mc/edit-lines)
          ("C->" . mc/mark-next-like-this)
          ("C-<" . mc/mark-prev-like-this)
          ("C-c C-<" . mc/mark-all-like-this)))
 #+END_SRC

* Expand region

Add expand-region

#+BEGIN_SRC emacs-lisp
  (use-package expand-region
    :bind
    ("C-=" . er/expand-region)
    ("C-+" . er/contract-region))
#+END_SRC

* Magit

Include magit

#+BEGIN_SRC emacs-lisp
  (use-package magit
    :bind ("C-x g" . magit-status)
    :config
    (add-hook 'git-commit-setup-hook 'git-commit-turn-on-flyspell))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package forge
    :after magit)
#+END_SRC

#+BEGIN_SRC emacs-lisp
    (use-package magit-todos
      :ensure t
      :after magit
      :config
      (setq magit-todos-exclude-globs '("node_modules")))
#+END_SRC

* wgrep

#+BEGIN_SRC emacs-lisp
  (use-package wgrep)
#+END_SRC

* Which-key

Which key to show a list of keys that follow a speicific key-chord

#+BEGIN_SRC emacs-lisp
 (use-package which-key
   :config (which-key-mode))
#+END_SRC

* Ivy / Counsel / Swiper

Use the ivy completion frontend, and the set of ivy-enhanced emacs commands

#+BEGIN_SRC emacs-lisp
  (use-package ivy
    :diminish ivy-mode
    :config (ivy-mode 1))

  (use-package counsel
    :config
    (global-set-key (kbd "M-x") 'counsel-M-x)
    (global-set-key (kbd "C-x C-f") 'counsel-find-file)
    ;(global-set-key (kbd "<f1> f") 'counsel-describe-function)
    ;(global-set-key (kbd "<f1> v") 'counsel-describe-variable)
    ;(global-set-key (kbd "<f1> l") 'counsel-find-library)
    ;(global-set-key (kbd "<f2> i") 'counsel-info-lookup-symbol)
    ;(global-set-key (kbd "<f2> u") 'counsel-unicode-char)
    (global-set-key (kbd "C-c g") 'counsel-git)
    (global-set-key (kbd "C-c j") 'counsel-git-grep)
    (global-set-key (kbd "C-c k") 'counsel-ag)
    ;(global-set-key (kbd "C-x l") 'counsel-locate)
    ;(global-set-key (kbd "C-S-o") 'counsel-rhythmbox)
    ;(define-key read-expression-map (kbd "C-r") 'counsel-expression-history)
    )

  (use-package amx
    :ensure t
    :after ivy
    :custom
    (amx-backend 'auto)
    (amx-save-file "~/.emacs.d/amx-items")
    (amx-history-length 50)
    (amx-show-key-bindings nil)
    :config
    (amx-mode 1))
#+END_SRC

Use the ivy enhanced version of =isearch=

#+BEGIN_SRC emacs-lisp
  (use-package swiper
    :bind (("\C-s" . swiper-isearch))
    :config
    (progn
      (ivy-mode 1)
      (setq ivy-use-virtual-buffers t)
      (setq enable-recursive-minibuffers t)
      ;(global-set-key (kbd "C-c C-r") 'ivy-resume)
      ;(global-set-key (kbd "<f6>") 'ivy-resume)
      ))
 #+END_SRC

Make use of the enriched version of ivy commands to display more information about the tasks etc.

#+BEGIN_SRC emacs-lisp
  (use-package ivy-rich
    :ensure t
    :config
    (ivy-rich-mode 1))
#+END_SRC

* ibuffer

Prefer the use of =ibuffer= instead of the default buffer list
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-x C-b") 'ibuffer)
  (setq ibuffer-saved-filter-groups
        '(("default"
           ("emacs-config" (or (filename . ".emacs.d")
                               (filename . "emacs-config")))
           ("Org" (or (mode . org-mode)
                      (filename . "OrgMode")))
           ("Magit" (name . "magit.*"))
           ("Help" (or (name . ".*Help.*")
                       (name . ".*Apropos.*")
                       (name . ".*info.*"))))))

  (add-hook 'ibuffer-mode-hook
            (lambda ()
              (ibuffer-auto-mode 1)
              (ibuffer-switch-to-saved-filter-groups "default")))

  (setq ibuffer-show-empty-filter-groups nil)

  (setq ibuffer-expert t)
#+END_SRC

* Dashboard

Display a simple dashboard at startup
#+BEGIN_SRC emacs-lisp
  (use-package dashboard
    :config
    (dashboard-setup-startup-hook)
    (setq show-week-agenda-p t)
    (setq dashboard-items '((projects . 10)
                            (agenda . 10)
                            (recents  . 10))))
#+END_SRC

* Ace-window
Faster switching between windows, via =ace-window=
#+BEGIN_SRC emacs-lisp
  (use-package ace-window
    :config
    (global-set-key (kbd "M-o") 'ace-window))
#+END_SRC

Simpler interactions with the kill-ring
#+BEGIN_SRC emacs-lisp
  (use-package popup-kill-ring
    :bind ("M-y" . popup-kill-ring))
#+END_SRC

* Hungry delete

Automatically delete whitespace in a sensible way with "smart" hungry delete
#+BEGIN_SRC emacs-lisp
  (use-package hungry-delete
    :config
    (global-hungry-delete-mode))
#+END_SRC

* Narrowing

Narrowing and widening a little faster?

#+BEGIN_SRC emacs-lisp
  ;; (use-package recursive-narrow
  ;;   :config
  ;;   (add-hook 'post-command-hook 'my-narrowed-fringe-status)

  ;;   (defun my-narrowed-fringe-status ()
  ;;     "Make the fringe background reflect the buffer's narrowing status."
  ;;     (set-face-attribute
  ;;      'fringe nil :background (if (buffer-narrowed-p)
  ;;                                  "#999999" ;;my-fringe-narrow-bg
  ;;                                nil)))
  ;;   )
#+END_SRC

* Appearance

#+BEGIN_SRC emacs-lisp
  (use-package all-the-icons)

  (use-package doom-modeline
    :init
    (setq doom-modeline-buffer-file-name-style 'relative-from-project)
    ;;(setq doom-modeline-icon nil)
    ;;(setq doom-modeline-major-mode-icon nil)
    ;;(setq doom-modeline-minor-modes t)
    :hook (after-init . doom-modeline-init))


  (use-package modus-vivendi-theme
    :ensure t)

  ;; (use-package doom-themes
  ;;   :config
  ;;   (setq doom-themes-enable-bold t    ; if nil, bold is universally disabled
  ;;         doom-themes-enable-italic t  ; if nil, italics is universally disabled
  ;;
  ;;         ;; doom-one specific settings
  ;;         ;;doom-one-brighter-modeline nil
  ;;         doom-one-brighter-comments t
  ;;         )
  ;;
  ;;   ;; Corrects (and improves) org-mode's native fontification.
  ;;   (doom-themes-org-config)
  ;;
  ;;   (load-theme 'doom-one t))
#+END_SRC


Highlight the current line.

#+BEGIN_SRC emacs-lisp
  (global-hl-line-mode 1)
  ;; Set the colour for the marked region to something lighter
  ;;(set-face-background 'hl-line "#030333")
  (set-face-background 'hl-line "#111")
#+END_SRC

# Improve look and feel of titlebar on Macos. Set =ns-appearance= to
# =dark= for white title text and =nil= for black title text.

#+BEGIN_SRC emacs-lisp
  ;; (with-system darwin
  ;;   (add-to-list 'default-frame-alist '(ns-transparent-titlebar . t))
  ;;   (add-to-list 'default-frame-alist '(ns-appearance . dark)))
#+END_SRC


Inline display of colours

#+BEGIN_SRC emacs-lisp
  (use-package rainbow-mode
    :init
    (add-hook 'prog-mode-hook 'rainbow-mode))
#+END_SRC

# Add a visual inidcator when switching to a different window

#+BEGIN_SRC emacs-lisp
  ;; (use-package beacon
  ;;   :config
  ;;   (beacon-mode 1))
#+END_SRC

Use the "forward" uniquify scheme for buffer disambiguation

#+BEGIN_SRC emacs-lisp
(setq uniquify-buffer-name-style 'forward)
#+END_SRC

* Hippie-expand

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "M-/") 'hippie-expand)
  (setq hippie-expand-try-functions-list
        '(try-expand-dabbrev
          try-expand-dabbrev-all-buffers try-expand-dabbrev-from-kill
          try-complete-file-name-partially try-complete-file-name
          try-expand-all-abbrevs try-expand-list try-expand-line
          try-complete-lisp-symbol-partially try-complete-lisp-symbol))
#+END_SRC

* Rainbow delimeters
Some general configuration for development that is agnostic of
language.

Use parens highlighting to make reading the code a little simpler

#+BEGIN_SRC emacs-lisp
  (use-package rainbow-delimiters
    :config
    (add-hook 'prog-mode-hook 'rainbow-delimiters-mode)
    (add-hook 'TeX-update-style-hook #'rainbow-delimiters-mode)
    (set-face-attribute 'rainbow-delimiters-unmatched-face nil
                        :foreground "red"
                        :inherit 'error
                        :box t)
    )
#+END_SRC

* Autocomplete

Completion service using =company-mode=

#+BEGIN_SRC emacs-lisp
  (use-package company
    :config
;;    (setq company-idle-delay 0)
;;    (setq company-minimum-prefix-length 3)

    (global-company-mode t))
#+END_SRC

* Flycheck

=Flycheck= to allow for the checking of code

#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    ;; :diminish flycheck-mode
    :demand t
    :init
    (setq flycheck-check-syntax-automatically '(mode-enabled save)
          flycheck-checker-error-threshold 2000)
    :config
    (mapc (lambda (mode)
            (add-hook mode 'flycheck-mode))
          '(elm-mode-hook
            emacs-lisp-mode-hook
            haskell-mode-hook
            scala-mode-hook
            ))
    (add-hook 'sh-mode-hook
              (lambda ()
                (flycheck-select-checker 'sh-shellcheck)))
    )
#+END_SRC

* Projectile

Project management using projectile

#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :diminish projectile-mode
    :init
    (setq projectile-keymap-prefix (kbd "C-c p"))
    :config
    (setq projectile-indexing-method 'alien)
    ;;(setq projectile-enable-caching t)
    (setq projectile-completion-system 'ivy)
    (setq projectile-switch-project-action 'magit-status)
    (setq projectile-git-submodule-command nil) ;; Stupid submodule bullshit
    (add-to-list 'projectile-globally-ignored-files "node_modules")
    (projectile-global-mode))
#+END_SRC

* yasnippet

Snippet support

#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :config
    (use-package yasnippet-snippets)
    (yas-reload-all))
#+END_SRC

* Mark TODO / FIXME items

Highlight TODO / FIXME strings in buffers

# #+BEGIN_SRC emacs-lisp
#   (use-package fic-mode
#     :hook prog-mode)
# #+END_SRC

* Dumb-jump

#+BEGIN_SRC emacs-lisp
  (use-package dumb-jump
    ;; :bind (("M-g o" . dumb-jump-go-other-window)
    ;;        ("M-g j" . dumb-jump-go)
    ;;        ("M-g x" . dumb-jump-go-prefer-external)
    ;;        ("M-g z" . dumb-jump-go-prefer-external-other-window))
    :init
    (dumb-jump-mode)
    :config
    (setq dumb-jump-selector 'ivy)
    ;; Add some config for elm files
    (nconc dumb-jump-language-file-exts
           '((:language "elm" :ext "elm" :agtype "elm" :rgtype "elm")))
    (nconc dumb-jump-language-comments
           '((:comment "--" :language "elm")))
    (nconc dumb-jump-find-rules
           ;; Rules, based off the haskell syntax
           '((:type "module" :supports ("ag" "rg") :language "elm"
                    :regex "^module\\s+JJJ\\s+"
                    :tests ("model Test exposing (exportA, exportB)"))

             (:type "type" :supports ("ag" "rg" "grep" "git-grep") :language "elm"
                    :regex "^type\\s+JJJ\\b"
                    :tests ("type Test"))
             (:type "type" :supports ("ag" "rg" "grep" "git-grep") :language "elm"
                    :regex "^type\\s+alias\\s+JJJ\\b"
                    :tests ("type alias Test" "type alias Model ="))
             (:type "function" :supports ("ag" "rg" "grep" "git-grep") :language "elm"
                    :regex "^port\\s+JJJ\\b\\s*:[^:]"
                    :tests ("port requestPopup :"))
             (:type "function" :supports ("ag" "rg" "grep" "git-grep") :language "elm"
                    :regex "^\\s*JJJ\\s*:[^:].*->.*"
                    :tests ("foo : Int -> Int"))
             ))
    ;;--regex-Elm=/^ *([[:lower:]][[:alnum:]_]+)[[:blank:]]*:[^:][^-]+$/\1/c,constant,constants/
    )
#+END_SRC

* Outshine mode

#+BEGIN_SRC emacs-lisp
  (use-package outshine
    :hook LaTeX-mode)
#+END_SRC

* Nix and nixpkg

#+BEGIN_SRC emacs-lisp
  (use-package nix-mode
    :mode "\\.nix\\'")

#+END_SRC

* Terminal

 #+BEGIN_SRC emacs-lisp
   (defvar my-term-shell "/usr/local/bin/fish")
   (defadvice ansi-term (before force-bash)
     (interactive (list my-term-shell)))
   (ad-activate 'ansi-term)

   ;;(global-set-key (kbd "<M-return>") 'ansi-term)
 #+END_SRC

* org-mode settings
** Appearance

Improve the appearance of bullet points in Emacs:

#+BEGIN_SRC emacs-lisp
    (use-package org-bullets
      :defer t
      :config
  ;;    (setq org-bullets-bullet-list '("∙"))
      (add-hook 'org-mode-hook 'org-bullets-mode))
#+END_SRC

Set colours for priorities

#+BEGIN_SRC emacs-lisp
(setq org-priority-faces '((?A . (:foreground "#F0DFAF" :weight bold))
                           (?B . (:foreground "LightSteelBlue"))
                           (?C . (:foreground "OliveDrab"))))
#+END_SRC

** Keybinds

Define org-mode related keybinds:

#+BEGIN_SRC emacs-lisp
  (define-key global-map (kbd "C-c l") 'org-store-link)
  (define-key global-map (kbd "C-c a") 'org-agenda)
  (define-key global-map (kbd "C-c c") 'org-capture)
  (setq org-log-done t)
#+END_SRC

** Agenda file locations

Define the locations of the different org files:

#+BEGIN_SRC emacs-lisp
  (setq org-agenda-files (list "~/org/gtd.org"
                               "~/org/projects.org"
                               "~/org/work.org"
                               "~/org/calendar.org"
                               "~/org/call.org"))
#+END_SRC

Nicer indenting in =org-mode= files

#+BEGIN_SRC emacs-lisp
  (add-hook 'org-mode-hook 'org-indent-mode)
#+END_SRC

** Alerts

Add =org-alert= to display some alerts on the desktop

#+BEGIN_SRC emacs-lisp
  (use-package org-alert
    :config
    (with-system darwin
                 (setq alert-default-style 'message))
    (with-system gnu/linux
                 (setq alert-default-style 'libnotify)))

#+END_SRC

** Capture templates

#+BEGIN_SRC emacs-lisp
  (setq org-capture-templates
        '(("t" "Todo" entry
           (file+headline "~/org/gtd.org" "Tasks")
           "* TODO %?\n  %i\n  %a")
          ("p" "Project Todo" entry
           (file+headline "~/org/projects.org" "Tasks")
           "* TODO %?\n  %i\n  %a")
          ("w" "Work Todo" entry
           (file+headline "~/org/work.org" "Tasks")
           "* TODO %?\n  %i\n  %a")
          ("c" "Call someone" entry
           (file+headline "~/org/call.org" "To call")
           "* TODO %?\n  %i\n")
          ))
#+END_SRC

** Google calendar integration

#+BEGIN_SRC emacs-lisp
  (defvar org-gcal-last-synced nil
    "The last time a org-gcal-sync was run")

  (use-package org-gcal
    :config
    (setq org-gcal-file-alist '(("gpampara@gmail.com" . "~/org/calendar.org")))

    (if org-gcal-last-synced
        (unless (string-equal 'org-gcal-last-synced (format-time-string "%Y-%m-%d"))
          (org-gcal-sync)
          (setq org-gcal-last-synced (format-time-string"%Y-%m-%d")))))

  ;;      (setq org-gcal-last-synced (format-time-string "%Y-%m-%d"))))

      ;; Create a timer to run the gcal-hook periodically for us, every hour
      ;;(run-at-time t 3600 'org-gcal-sync))
      ;(add-hook 'org-agenda-mode-hook (lambda () (org-gcal-sync)))
      ;(add-hook 'org-capture-after-finalize-hook (lambda () (org-gcal-sync))))

#+END_SRC

** org-beamer

#+BEGIN_SRC emacs-lisp
(eval-after-load "ox-latex"

  ;; update the list of LaTeX classes and associated header (encoding, etc.)
  ;; and structure
  '(add-to-list 'org-latex-classes
                `("beamer"
                  ,(concat "\\documentclass[presentation]{beamer}\n"
                           "[DEFAULT-PACKAGES]"
                           "[PACKAGES]"
                           "[EXTRA]\n")
                  ("\\section{%s}" . "\\section*{%s}")
                  ("\\subsection{%s}" . "\\subsection*{%s}")
                  ("\\subsubsection{%s}" . "\\subsubsection*{%s}"))))
#+END_SRC

** org-noter

#+BEGIN_SRC emacs-lisp
  (use-package org-noter
    :after org
    :ensure t
    :config
    (setq org-noter-default-notes-file-names '("notes.org")
          org-noter-separate-notes-from-heading t))
#+END_SRC
* Writing

Upgrade the dictionary used to a more up-to-date, recent version.

#+BEGIN_SRC emacs-lisp
  (cond
   ;; try hunspell at first
   ;; if hunspell does NOT exist, use aspell
   ((executable-find "hunspell")
    (setq ispell-program-name "hunspell")
    (setq ispell-local-dictionary "en_GB")
    (setq ispell-local-dictionary-alist
          ;; Please note the list `("-d" "en_US")` contains ACTUAL parameters passed to hunspell
          ;; You could use `("-d" "en_US,en_US-med")` to check with multiple dictionaries
          '(("en_US" "[[:alpha:]]" "[^[:alpha:]]" "[']" nil ("-d" "en_US") nil utf-8)
            )))

   ((executable-find "aspell")
    (setq ispell-program-name "aspell")
    ;; Please note ispell-extra-args contains ACTUAL parameters passed to aspell
    (setq ispell-extra-args '("--sug-mode=ultra" "--lang=en_US"))))
#+END_SRC

=writegood-mode= highlights bad words, weasels etc. Also has functions
to calculate readability of writing.

#+BEGIN_SRC emacs-lisp
  (use-package writegood-mode
  ;;:bind ("C-c g" . writegood-mode)
    :init
    (add-hook 'TeX-update-style-hook #'writegood-mode)
    :config
    (add-to-list 'writegood-weasel-words "actionable"))
#+END_SRC

Add =langtool= as an additional tool to use

#+BEGIN_SRC emacs-lisp
  (use-package langtool
    :config
    (setq langtool-language-tool-jar "/usr/local/Cellar/languagetool/4.3/libexec/languagetool-commandline.jar"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package writeroom-mode
    :bind (:map writeroom-mode-map
                ("C-s-," . writeroom-decrease-width)
                ("C-s-." . writeroom-increase-width)
                ("C-s-=" . writeroom-adjust-width))
    :config
    (add-hook 'LaTeX-mode-hook 'writeroom-mode)
    (add-hook 'LaTeX-mode-hook 'adaptive-wrap-prefix-mode)
    (setq writeroom-width 120)
    (advice-add 'text-scale-adjust :after #'visual-fill-column-adjust))
#+END_SRC

** thesaurus / dictionary

#+BEGIN_SRC emacs-lisp
  (with-system darwin
    (use-package osx-dictionary
      :bind (("M-\\" . osx-dictionary-search-pointer))))
#+END_SRC

* Language Server (LSP)

#+BEGIN_SRC emacs-lisp
  (use-package lsp-mode
    :commands lsp lsp-deferred
    :custom
    (lsp-auto-guess-root nil)
    (lsp-prefer-flymake nil)
    ;;:hook (;;(scala-mode . lsp-deferred)
           ;;(elm-mode . lsp-deferred)
      ;;     )
    )

  (use-package lsp-ui
    :after lsp-mode
    :diminish
    :commands lsp-ui-mode
    :custom-face
    (lsp-ui-doc-background ((t (:background nil))))
    (lsp-ui-doc-header ((t (:inherit (font-lock-string-face italic)))))
    :custom
    (lsp-ui-doc-enable t)
    (lsp-ui-doc-header t)
    (lsp-ui-doc-include-signature t)
    (lsp-ui-doc-position 'top)
    (lsp-ui-doc-border (face-foreground 'default))
    (lsp-ui-sideline-enable nil)
    (lsp-ui-sideline-ignore-duplicate t)
    (lsp-ui-sideline-show-code-actions nil)
    :config
    ;; Use lsp-ui-doc-webkit only in GUI
    (setq lsp-ui-doc-use-webkit t)
    ;; WORKAROUND Hide mode-line of the lsp-ui-imenu buffer
    ;; https://github.com/emacs-lsp/lsp-ui/issues/243
    (defadvice lsp-ui-imenu (after hide-lsp-ui-imenu-mode-line activate)
      (setq mode-line-format nil))
    (defun lsp--send-did-save-p () t))

  (use-package company-lsp
    ;;:commands company-lsp
    :config
    (push 'company-lsp company-backends))

  ;; ;;  (use-package helm-lsp :commands helm-lsp-workspace-symbol)
  ;; ;;  (use-package lsp-treemacs :commands lsp-treemacs-errors-list)
#+END_SRC

* Auto-fill comments
#+BEGIN_SRC emacs-lisp
  (add-hook 'prog-mode (lambda ()
                         ((auto-fill-mode 1)
                          (setq comment-auto-fill-only-comments t))))
#+END_SRC
* Javascript and "friends"

Some additional modes for Javascript (rubbish language)

#+BEGIN_SRC emacs-lisp
  (use-package coffee-mode
    :mode "\\.coffee\\'")
#+END_SRC

Highlighting for pug/jade templates

#+BEGIN_SRC emacs-lisp
  (use-package pug-mode
    :mode ("\\.pug\\'" "\\.jade\\'")
    :config
    (setq pug-tab-width 4))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package json-mode
    :mode "\\.json\\'")
#+END_SRC

* Elm

Add =elm-mode= and =flycheck= configuration for editing of elm
buffers.

#+BEGIN_SRC emacs-lisp
  (use-package flycheck-elm
    :after flycheck
    :config
    '(add-hook 'flycheck-mode-hook 'flycheck-elm-setup))

  (use-package elm-mode
    :mode "\\.elm\\'"
    :init
    (add-to-list 'company-backends 'company-elm)
    :config
    (add-hook 'after-init-hook #'global-flycheck-mode)
    (add-hook 'elm-mode-hook #'elm-format-on-save-mode))
#+END_SRC

* Haskell

Some _very_ basic Haskell config

#+BEGIN_SRC emacs-lisp
  (defun fix-imports ()
    "Fixes imports."
    (interactive)
    (sort-lines nil (region-beginning) (region-end))
    (align-regexp (region-beginning) (region-end) "\\(\\s-*\\)#-"))

  (use-package haskell-mode
    :mode "\\.hs\\'")
#+END_SRC

* Polymode

Define polymode to allow multiple modes in a single buffer. Handy for
=knitr= and friends

#+BEGIN_SRC emacs-lisp
  (use-package polymode
    :mode
    ("\\.Rnw" . poly-noweb+r-mode))
#+END_SRC

* LaTeX

Setup AUCTex for some nice LaTeX support in emacs. This workflow is
centered around using =latexmk= as the build tool and that the LaTeX
project is version controlled in git.

From the project specific =.latexmkrc= we can then determine relative
pathing for files to correctly allow for the automatic setting of the
=TeX-master= variable, removing the need to spoil the source files
themselves with local config comment strings.

#+BEGIN_SRC emacs-lisp
  ;; https://www.emacswiki.org/emacs/AUCTeX
  ;; Automagic detection of master file
  ;; (defun guess-TeX-master (filename)
  ;;   "Guess the master file for FILENAME from currently open .tex files."
  ;;   (let ((candidate nil)
  ;;         (filename (file-name-nondirectory filename)))
  ;;     (message "riunning the guess tex master function")
  ;;     (save-excursion
  ;;       (dolist (buffer (buffer-list))
  ;;         (with-current-buffer buffer
  ;;           (let ((name (buffer-name))
  ;;                 (file buffer-file-name))
  ;;             (if (and file (string-match "\\.tex$" file))
  ;;                 (progn
  ;;                   (goto-char (point-min))
  ;;                   (if (re-search-forward (concat "\\\\input{" filename "}") nil t)
  ;;                       (setq candidate file))
  ;;                   (if (re-search-forward (concat "\\\\include{" (file-name-sans-extension filename) "}") nil t)
  ;;                       (setq candidate file))))))))
  ;;     (if candidate
  ;;         (message "TeX master document: %s" (file-name-nondirectory candidate)))
  ;;     candidate))

  ;; (defun TeX-texify-sentinel (&optional proc sentinel)
  ;;   "Non-interactive! Call the standard-sentinel of the current LaTeX-process.
  ;; If there is still something left do do start the next latex-command."
  ;;   (set-buffer (process-buffer proc))
  ;;   (funcall TeX-texify-sentinel proc sentinel)
  ;;   (let ((case-fold-search nil))
  ;;     (when (string-match "\\(finished\\|exited\\)" sentinel)
  ;;       (set-buffer TeX-command-buffer)
  ;;       (unless (plist-get TeX-error-report-switches (intern (TeX-master-file)))
  ;;         (TeX-texify)))))

  ;; (defun TeX-texify ()
  ;;   "Get everything done."
  ;;   (interactive)
  ;;   (let ((nextCmd (TeX-command-default (TeX-master-file)))
  ;;         proc)
  ;;     (if (and (null TeX-texify-Show)
  ;;              (equal nextCmd TeX-command-Show))
  ;;         (when  (called-interactively-p 'any)
  ;;           (message "TeX-texify: Nothing to be done."))
  ;;       (TeX-command nextCmd 'TeX-master-file)
  ;;       (when (or (called-interactively-p 'any)
  ;;                 (null (boundp 'TeX-texify-count-same-command))
  ;;                 (null (boundp 'TeX-texify-last-command))
  ;;                 (null (equal nextCmd TeX-texify-last-command)))
  ;;         (mapc 'make-local-variable '(TeX-texify-sentinel TeX-texify-count-same-command TeX-texify-last-command))
  ;;         (setq TeX-texify-count-same-command 1))
  ;;       (if (>= TeX-texify-count-same-command TeX-texify-max-runs-same-command)
  ;;           (message "TeX-texify: Did %S already %d times. Don't want to do it anymore." TeX-texify-last-command TeX-texify-count-same-command)
  ;;         (setq TeX-texify-count-same-command (1+ TeX-texify-count-same-command))
  ;;         (setq TeX-texify-last-command nextCmd)
  ;;         (and (null (equal nextCmd TeX-command-Show))
  ;;              (setq proc (get-buffer-process (current-buffer)))
  ;;              (setq TeX-texify-sentinel (process-sentinel proc))
  ;;              (set-process-sentinel proc 'TeX-texify-sentinel))))))

  (defun ales/fill-paragraph (&optional P)
    "When called with prefix argument call `fill-paragraph'.
  Otherwise split the current paragraph into one sentence per line.
  Optional argument P Dunno?"
    (interactive "P")
    (if (not P)
        (save-excursion
          (let ((fill-column 12345678)) ;; relies on dynamic binding
            (fill-paragraph) ;; this will not work correctly if the paragraph is
                             ;; longer than 12345678 characters (in which case the
                             ;; file must be at least 12MB long. This is unlikely.)
            (let ((end (save-excursion
                         (forward-paragraph 1)
                         (backward-sentence)
                         (point-marker))))  ;; remember where to stop
              (beginning-of-line)
              (while (progn (forward-sentence)
                            (<= (point) (marker-position end)))
                (just-one-space) ;; leaves only one space, point is after it
                (delete-char -1) ;; delete the space
                (newline)        ;; and insert a newline
                (LaTeX-indent-line) ;; I only use this in combination with late, so this makes sense
                ))))
      ;; otherwise do ordinary fill paragraph
      (fill-paragraph P)))

  (defun extract-default-files ()
    "Extract latex project main file from the Makefile in a temporary buffer."
    (let* ((default-directory (locate-dominating-file "." "Makefile"))
           (target-file (concat default-directory "Makefile")))
      (with-temp-buffer
        (insert-file-contents target-file)
        (goto-char (point-min))
        (when (re-search-forward "MAINFILE\s+:=\s+\\(.*\\)\s*")
          (concat default-directory (match-string 1))))
      ))

  (defun relative-master (path)
    "Determine the relative PATH to the master file, calcuated by `extract-default-files'.
  Argument PATH the path to determine the relative path from."
    (let ((master-file (extract-default-files)))
      (f-relative master-file (f-dirname path))))

  (defun reload-after-TeX-complete (process msg)
    "Reload any associated PDFView buffers, after compilation succeeds.
  Argument PROCESS The sentinel process.
  Argument MSG The message."
    (TeX-command-sentinel process msg)

    ;; Now update the produced synctex file to cater for the case of Sweave/knitr interactions
    (dolist ($buf (buffer-list (current-buffer)))
      (with-current-buffer $buf
        (when (eq (buffer-local-value 'major-mode $buf) 'pdf-view-mode)
          (message "Reloading PDF: %s" (buffer-name $buf))
          (pdf-view-revert-buffer :ignore-auto :noconfirm))))
    )

  (use-package outline-magic)

  (use-package tex-site
    :ensure auctex
    :after (tex latex)
    :mode (("\\.tex\\'" . LaTeX-mode))
    :commands (latex-mode LaTeX-mode plain-tex-mode)
    :bind (:map LaTeX-mode-map
                ("M-q" . ales/fill-paragraph))
    :init
    (add-hook 'LaTeX-mode-hook 'LaTeX-preview-setup)
    (add-hook 'LaTeX-mode-hook 'flyspell-mode)
    (add-hook 'LaTeX-mode-hook 'turn-on-reftex)
    (add-hook 'LaTeX-mode-hook 'LaTeX-math-mode)
    (add-hook 'LaTeX-mode-hook 'visual-line-mode)

    ;; to use pdfview with auctex
    (add-hook 'LaTeX-mode-hook 'pdf-tools-install)

    ;; to use pdfview with auctex
    (setq TeX-view-program-selection '((output-pdf "pdf-tools"))
          TeX-source-correlate-start-server t)
    (setq TeX-view-program-list '(("pdf-tools" "TeX-pdf-tools-sync-view")))

    (add-hook 'LaTeX-mode-hook (lambda ()
                                 (setq TeX-master (relative-master (buffer-file-name)))
                                 (add-to-list 'TeX-command-list '("Make" "make" TeX-run-TeX nil t))
                                 (add-to-list 'TeX-command-list
                                              '("custom" "something"
                                                (lambda (name command file)
                                                  (message name command file)
                                                  (let ((TeX-save-query nil)
                                                        (TeX-process-asynchronous t)
                                                        (TeX-error-overview-open-after-TeX-run t)
                                                        (master-file (TeX-master-file))
                                                        (process (TeX-command-menu "Make")))
                                                    (set-process-sentinel process 'reload-after-TeX-complete)))
                                                nil t)
                                              )
                                 ))

    (add-hook 'outline-minor-mode-hook
              (lambda ()
                (define-key outline-minor-mode-map ["\C-o"] 'outline-cycle)))
    :config
    (setq TeX-auto-save t
          TeX-parse-self t
          TeX-save-query nil
          TeX-command-force "custom"
          TeX-PDF-mode t
          reftex-plug-into-AUCTeX t
          reftex-use-external-file-finders t
          LaTeX-csquotes-open-quote "\\enquote{"
          LaTeX-csquotes-close-quote "}"
          reftex-bibliography-commands '("bibliography" "nobibliography" "addbibresource") ;; Make reftex try play nicer with biblatex
          reftex-cite-format 'natbib)

    ;; Fancy verbatim config for code blocks in thesis
    (add-to-list 'LaTeX-verbatim-environments "code")
    (add-to-list 'LaTeX-indent-environment-list '("code" current-indentation))

    ;; Spelling
    (setq ispell-tex-skip-alists
          '((
             ;;("%\\[" . "%\\]") ; AMStex block comment...
             ;; All the standard LaTeX keywords from L. Lamport's guide:
             ;; \cite, \hspace, \hspace*, \hyphenation, \include, \includeonly
             ;; \input, \label, \nocite, \rule (in ispell - rest included here)
             ("\\\\addcontentsline"              ispell-tex-arg-end 2)
             ("\\\\add\\(tocontents\\|vspace\\)" ispell-tex-arg-end)
             ("\\\\\\([aA]lph\\|arabic\\)"   ispell-tex-arg-end)
             ("\\\\author"                         ispell-tex-arg-end)
             ;; New regexps here --- kjh
             ("\\\\\\(text\\|paren\\)cite" ispell-tex-arg-end)
             ("\\\\cite\\(t\\|p\\|year\\|yearpar\\)" ispell-tex-arg-end)
             ("\\\\bibliographystyle"                ispell-tex-arg-end)
             ("\\\\gls"                ispell-tex-arg-end)
             ("\\\\cref"               ispell-tex-arg-end)
             ("\\\\makebox"                  ispell-tex-arg-end 0)
             ("\\\\e?psfig"                  ispell-tex-arg-end)
             ("\\\\document\\(class\\|style\\)" .
              "\\\\begin[ \t\n]*{[ \t\n]*document[ \t\n]*}"))
            (
             ;; delimited with \begin.  In ispell: displaymath, eqnarray,
             ;; eqnarray*, equation, minipage, picture, tabular,
             ;; tabular* (ispell)
             ("\\(figure\\|table\\)\\*?"     ispell-tex-arg-end 0)
             ("\\(equation\\|eqnarray\\)\\*?"     ispell-tex-arg-end 0)
             ("list"                                 ispell-tex-arg-end 2)
             ("program" . "\\\\end[ \t\n]*{[ \t\n]*program[ \t\n]*}")
             ("verbatim\\*?"."\\\\end[ \t\n]*{[ \t\n]*verbatim\\*?[ \t\n]*}")
             ("lstlisting\\*?"."\\\\end[ \t\n]*{[ \t\n]*lstlisting\\*?[ \t\n]*}"))))
    )
#+END_SRC

Now add =pdf-tools= for nicer PDF interactions

#+BEGIN_SRC emacs-lisp
  (use-package pdf-tools
    :defer t
    :magic ("%PDF" . pdf-view-mode)
    :config
    (with-system darwin
      ;; https://github.com/politza/pdf-tools/issues/480#issuecomment-473707355
      (setenv "PKG_CONFIG_PATH" "/usr/local/lib/pkgconfig:/usr/local/Cellar/libffi/3.2.1/lib/pkgconfig"))
    ;; initialise
    (pdf-tools-install)
    ;; open pdfs scaled to fit page
    (setq-default pdf-view-display-size 'fit-page)
    ;; automatically annotate highlights
    (setq pdf-annot-activate-created-annotations t)
    ;; use normal isearch
    (define-key pdf-view-mode-map (kbd "C-s") 'isearch-forward))
#+END_SRC

Add the =ebib= package to manage =.bib= files

#+BEGIN_SRC emacs-lisp
  (use-package ebib)
#+END_SRC
* R

#+BEGIN_SRC emacs-lisp
  (use-package poly-R)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package ess
    :after ess-site)
#+END_SRC

* Scala

Use =scala-mode= for scala syntax highlighting

#+BEGIN_SRC emacs-lisp
  (use-package scala-mode
    :mode "\\.s\\(cala\\|bt\\)$")

  (use-package sbt-mode
    :commands sbt-start sbt-command
    :config
    ;; WORKAROUND: https://github.com/ensime/emacs-sbt-mode/issues/31
    ;; allows using SPACE when in the minibuffer
    (substitute-key-definition
     'minibuffer-complete-word
     'self-insert-command
     minibuffer-local-completion-map))
#+END_SRC

* Terraform

#+BEGIN_SRC emacs-lisp
  (use-package terraform-mode
    :mode "\\.tf\\'")

  (use-package company-terraform
    :after terraform-mode
    :config
    (company-terraform-init))
#+END_SRC

* Dhall

#+BEGIN_SRC emacs-lisp
  (use-package dhall-mode
    :mode ("\\.dhall\\'"))
#+END_SRC

* YAML

#+BEGIN_SRC emacs-lisp
  (use-package yaml-mode
    :mode ("\\.y[a?]ml\\'"))

#+END_SRC
