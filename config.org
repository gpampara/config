#+TITLE: Emacs Config
#+AUTHOR: Gary Pamparà
#+TOC: true

This is the my emacs config as an =org-mode= configuration. The idea of
using this literate style is to keep the config as organized as
possible.

* General
** Configure package sources

#+BEGIN_SRC emacs-lisp
    ;; (let* ((no-ssl (and (memq system-type '(windows-nt ms-dos))
    ;;                     (not (gnutls-available-p))))
    ;;        (proto (if no-ssl "http" "https")))
    ;;   ;; Comment/uncomment these two lines to enable/disable MELPA and MELPA Stable as desired
    ;;   (add-to-list 'package-archives (cons "melpa" (concat proto "://melpa.org/packages/")) t)
    ;;   ;;(add-to-list 'package-archives (cons "melpa-stable" (concat proto "://stable.melpa.org/packages/")) t)
    ;;   (when (< emacs-major-version 24)
    ;;     ;; For important compatibility libraries like cl-lib
    ;;     (add-to-list 'package-archives '("gnu" . (concat proto "://elpa.gnu.org/packages/")))))
  ;;  (package-initialize)

    ;; (setq package-archives
    ;;       '(("gnu" . "https://elpa.gnu.org/packages/")
    ;;         ("melpa" . "https://melpa.org/packages/")))

  (setq package-enable-at-startup nil)
  (add-to-list 'package-archives
               '("melpa" . "http://melpa.org/packages/"))
#+END_SRC



# ** Benchmark setup
# `benchmark-init` records the startup time by package so that we can
# debug problems. The package only records after it has been loaded, so
# we put it as early as possible.
#
# #+BEGIN_SRC emacs-lisp
# (use-package benchmark-init
#   :config
#   ;; To disable collection of benchmark data after init is done.
#   (add-hook 'after-init-hook 'benchmark-init/deactivate))
#
# (add-hook 'after-init-hook
#   (lambda () (message "loaded in %s" (emacs-init-time))))
# #+END_SRC
** Bootstrap use-package

#+BEGIN_SRC emacs-lisp
(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq use-package-always-ensure t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package auto-package-update
     :ensure t
     :config
     (setq auto-package-update-delete-old-versions t
           auto-package-update-interval 7
           auto-package-update-prompt-before-update t)
     (auto-package-update-maybe))
#+END_SRC

** Custom config functions

Evaluate an expression when the system is the defined value
#+BEGIN_SRC emacs-lisp
  (defmacro with-system (type &rest body)
    "Evaluate BODY if `system-type' equals TYPE."
    (declare (indent defun))
    `(when (eq system-type ',type)
       ,@body))
#+END_SRC

Open / visit the configuration file

#+BEGIN_SRC emacs-lisp
  (defun config-visit ()
    (interactive)
    (find-file "~/.emacs.d/config.org"))
  (global-set-key (kbd "C-c e") 'config-visit)
#+END_SRC

Reload the configuration

#+BEGIN_SRC emacs-lisp
  (defun config-reload ()
    (interactive)
    (org-babel-load-file (expand-file-name "~/.emacs.d/config.org")))
  (global-set-key (kbd "C-c r") 'config-reload)
#+END_SRC

** Load custom settings
#+BEGIN_SRC emacs-lisp
(setq custom-file "~/.emacs.d/custom-settings.el")
(load custom-file t)
#+END_SRC
** Load secrets
#+BEGIN_SRC emacs-lisp
  (load "~/.emacs.d/emacs.secrets" t)
#+END_SRC

** Adjust shell variables

Adjust shell environment variables, if needed

#+BEGIN_SRC emacs-lisp
  (setenv "SHELL" "/bin/bash")
  (setenv "LANG" "en_US.UTF-8")
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package exec-path-from-shell
    :ensure t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (with-system darwin
    (exec-path-from-shell-initialize))
#+END_SRC

Nix-shell related?

#+BEGIN_SRC emacs-lisp
  (use-package direnv)

#+END_SRC
** Preferences

Don't display the help screen

#+BEGIN_SRC emacs-lisp
  (setq inhibit-startup-screen t)
#+END_SRC

On  I use ⌘ as =meta= and prefer ⌥ to do nothing so I can still
insert special characters like easily.

#+BEGIN_SRC emacs-lisp
  (with-system darwin
    (setq mac-command-modifier 'meta
          mac-option-modifier 'none))
#+END_SRC

Disable passing various commands to the underlying  system:

#+BEGIN_SRC emacs-lisp
  (with-system darwin
    (setq mac-pass-command-to-system nil))
#+END_SRC

Some fancy  composition, particularly when using FiraCode fonts.

#+BEGIN_SRC emacs-lisp
  (with-system darwin
    (if (fboundp 'mac-auto-operator-composition-mode)
        (mac-auto-operator-composition-mode t)))
#+END_SRC

Turn off unwanted window decoration.

#+BEGIN_SRC emacs-lisp
  (tool-bar-mode -1)
  (scroll-bar-mode -1)
#+END_SRC

Make the =yes or no= prompts shorter.

#+BEGIN_SRC emacs-lisp
  (defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC

I usually don't want tabs, if I do I can set this buffer-local to
=t=. If I just want one tab then use =C-q= (=quoted-insert=) to insert
as a literal.

#+BEGIN_SRC emacs-lisp
  (setq-default indent-tabs-mode nil)
#+END_SRC

I'm not a fan of the backup and autosave functionality of emacs as
most of my work will be in a repository anyway.

#+BEGIN_SRC emacs-lisp
  (setq make-backup-files nil)
  (setq auto-save-default nil)

  (setq save-interprogram-paste-before-kill t
        apropos-do-all t
        mouse-yank-at-point t
        require-final-newline t
        visible-bell t
        load-prefer-newer t
        ediff-window-setup-function 'ediff-setup-windows-plain
        save-place-file (concat user-emacs-directory "places")
        create-lockfiles nil
        backup-directory-alist `(("." . (concat user-emacs-directory
                                                 "backups"))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq auto-window-vscroll nil)
#+END_SRC

*** Input settings

To force the change in usage, just completely disable any sort of
mouse event within Emacs.

#+BEGIN_SRC emacs-lisp
  ;; (use-package disable-mouse
  ;;   :ensure t
  ;;   :config
  ;;   (global-disable-mouse-mode))
#+END_SRC

*** Font settings
#+BEGIN_SRC emacs-lisp
  (when (window-system)
    (set-frame-font "Fira Code"))
  (set-language-environment "UTF-8")
  (set-default-coding-systems 'utf-8)
#+END_SRC

** Async support
#+BEGIN_SRC emacs-lisp
  (use-package async
    :ensure t)
#+END_SRC
* Interface
** General

 I *never* want whitespace at the end of lines. Remove it on save.

 #+BEGIN_SRC emacs-lisp
   (add-hook 'before-save-hook 'delete-trailing-whitespace)
 #+END_SRC

 Also, having a newline at the end of the file is a "good" thing:

 #+BEGIN_SRC emacs-lisp
   (setq require-final-newline t)
 #+END_SRC

 Add multiple cursor support.

 #+BEGIN_SRC emacs-lisp
 (use-package multiple-cursors
    :ensure t
    :bind (("C-S-c C-S-c" . mc/edit-lines)
          ("C->" . mc/mark-next-like-this)
          ("C-<" . mc/mark-prev-like-this)
          ("C-c C-<" . mc/mark-all-like-this)))
 #+END_SRC

Add expand-region

#+BEGIN_SRC emacs-lisp
  (use-package expand-region
    :ensure t
    :bind
    ("C-=" . er/expand-region)
    ("C-+" . er/contract-region))
#+END_SRC

Include magit

#+BEGIN_SRC emacs-lisp
  (use-package magit
    :ensure t
    :bind ("C-x g" . magit-status)
    :config
    (add-hook 'git-commit-setup-hook 'git-commit-turn-on-flyspell))
#+END_SRC

Which key to show a list of keys that follow a speicific key-chord
#+BEGIN_SRC emacs-lisp
 (use-package which-key
   :ensure t
   :config (which-key-mode))
#+END_SRC

Use the ivy completion frontend, and the set of ivy-enhanced emacs commands

#+BEGIN_SRC emacs-lisp
 (use-package ivy
   :ensure t
   :diminish ivy-mode
   :config (ivy-mode 1))

 (use-package counsel
   :ensure t
   :config
   (global-set-key (kbd "M-x") 'counsel-M-x)
   ;(global-set-key (kbd "C-x C-f") 'counsel-find-file)
   ;(global-set-key (kbd "<f1> f") 'counsel-describe-function)
   ;(global-set-key (kbd "<f1> v") 'counsel-describe-variable)
   ;(global-set-key (kbd "<f1> l") 'counsel-find-library)
   ;(global-set-key (kbd "<f2> i") 'counsel-info-lookup-symbol)
   ;(global-set-key (kbd "<f2> u") 'counsel-unicode-char)
   ;(global-set-key (kbd "C-c g") 'counsel-git)
   (global-set-key (kbd "C-c j") 'counsel-git-grep)
   ;(global-set-key (kbd "C-c k") 'counsel-ag)
   ;(global-set-key (kbd "C-x l") 'counsel-locate)
   ;(global-set-key (kbd "C-S-o") 'counsel-rhythmbox)
   ;(define-key read-expression-map (kbd "C-r") 'counsel-expression-history)
   )

 (use-package smex
   :ensure t)
#+END_SRC

Use the ivy enhanced version of =isearch=

#+BEGIN_SRC emacs-lisp
 (use-package swiper
   :ensure t
   :bind (("\C-s" . swiper))
   :config
   (progn
     (ivy-mode 1)
     (setq ivy-use-virtual-buffers t)
     (setq enable-recursive-minibuffers t)
     ;(global-set-key (kbd "C-c C-r") 'ivy-resume)
     ;(global-set-key (kbd "<f6>") 'ivy-resume)
     ))
 #+END_SRC

Prefer the use of =ibuffer= instead of the default buffer list
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-x C-b") 'ibuffer)
  (setq ibuffer-saved-filter-groups
        '(("default"
           ("emacs-config" (or (filename . ".emacs.d")
                               (filename . "emacs-config")))
           ("Org" (or (mode . org-mode)
                      (filename . "OrgMode")))
           ("Magit" (name . "\*magit\*"))
           ("Help" (or (name . "\*Help\*")
                       (name . "\*Apropos\*")
                       (name . "\*info\*"))))))

  (add-hook 'ibuffer-mode-hook
            (lambda ()
              (ibuffer-auto-mode 1)
              (ibuffer-switch-to-saved-filter-groups "default")))

  (setq ibuffer-show-empty-filter-groups nil)

  (setq ibuffer-expert t)
#+END_SRC

Display a simple dashboard at startup
#+BEGIN_SRC emacs-lisp
  (use-package dashboard
    :ensure t
    :config
    (dashboard-setup-startup-hook)
    (setq show-week-agenda-p t)
    (setq dashboard-items '((recents  . 10)
                            (projects . 5)
                            (agenda . 10))))
#+END_SRC

Faster switching between windows, via =ace-window=
#+BEGIN_SRC emacs-lisp
  (use-package ace-window
    :ensure t
    :config
    (global-set-key (kbd "M-o") 'ace-window))
#+END_SRC

Simpler interactions with the kill-ring
#+BEGIN_SRC emacs-lisp
  (use-package popup-kill-ring
    :ensure t
    :bind ("M-y" . popup-kill-ring))
#+END_SRC

Automatically delete whitespace in a sensible way with "smart" hungry delete
#+BEGIN_SRC emacs-lisp
  ;; (use-package smart-hungry-delete
  ;;   :ensure t
  ;;   :bind (("<backspace>" . smart-hungry-delete-backward-char)
  ;;                  ("C-d" . smart-hungry-delete-forward-char))
  ;;   :defer nil ;; dont defer so we can add our functions to hooks
  ;;   :config
  ;;   (add-hook 'prog-mode-hook 'smart-hungry-delete-default-prog-mode-hook)
  ;;   )

  (use-package hungry-delete
    :ensure t
    :config
    (global-hungry-delete-mode))
#+END_SRC

Some utility packages - is this actually required?

#+BEGIN_SRC emacs-lisp
  (use-package f
    :ensure t)
#+END_SRC

Use a plainer syntax for regexp

#+BEGIN_SRC emacs-lisp
  (use-package pcre2el
    :ensure t
    :config
    (pcre-mode))
#+END_SRC

** Appearance

#+BEGIN_SRC emacs-lisp
  (use-package all-the-icons)

  (use-package doom-modeline
        :ensure t
        :hook (after-init . doom-modeline-mode))

  (use-package doom-themes
    :ensure t
    :config
    (setq doom-themes-enable-bold t    ; if nil, bold is universally disabled
        doom-themes-enable-italic t  ; if nil, italics is universally disabled

        ;; doom-one specific settings
        doom-one-brighter-modeline nil
        doom-one-brighter-comments nil)

    (load-theme 'doom-one t))
#+END_SRC


Highlight the current line.

#+BEGIN_SRC emacs-lisp
  (global-hl-line-mode 1)
  ;; Set the colour for the marked region to something lighter
  (set-face-attribute 'region nil :background "#666")
#+END_SRC

Improve look and feel of titlebar on Macos. Set =ns-appearance= to
=dark= for white title text and =nil= for black title text.

#+BEGIN_SRC emacs-lisp
  (with-system darwin
    (add-to-list 'default-frame-alist '(ns-transparent-titlebar . t))
    (add-to-list 'default-frame-alist '(ns-appearance . dark)))
#+END_SRC


Inline display of colours

#+BEGIN_SRC emacs-lisp
  (use-package rainbow-mode
    :ensure t
    :init
    (add-hook 'prog-mode-hook 'rainbow-mode))
#+END_SRC

Add a visual inidcator when switching to a different window

#+BEGIN_SRC emacs-lisp
  (use-package beacon
    :ensure t
    :config
    (beacon-mode 1))
#+END_SRC

Use the "forward" uniquify scheme for buffer disambiguation

#+BEGIN_SRC emacs-lisp
(setq uniquify-buffer-name-style 'forward)
#+END_SRC

** Keybinds

*** Hippie-expand

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "M-/") 'hippie-expand)
  (setq hippie-expand-try-functions-list
        '(try-expand-dabbrev
          try-expand-dabbrev-all-buffers try-expand-dabbrev-from-kill
          try-complete-file-name-partially try-complete-file-name
          try-expand-all-abbrevs try-expand-list try-expand-line
          try-complete-lisp-symbol-partially try-complete-lisp-symbol))
#+END_SRC

* Development configuration
** General
Some general configuration for development that is agnostic of
language.

Use parens highlighting to make reading the code a little simpler

#+BEGIN_SRC emacs-lisp
  (use-package rainbow-delimiters
    :ensure t
    :config
    (add-hook 'prog-mode-hook 'rainbow-delimiters-mode)
    (add-hook 'TeX-update-style-hook #'rainbow-delimiters-mode)
    (set-face-attribute 'rainbow-delimiters-unmatched-face nil
                        :foreground "red"
                        :inherit 'error
                        :box t)
    )
#+END_SRC


# Let emacs try to help with keeping parentheses balanced.
#
# #+BEGIN_SRC emacs-lisp
#   (use-package smartparens
#     :diminish smartparens-mode
#     :config
#     (add-hook 'prog-mode-hook 'smartparens-mode))
# #+END_SRC

Completion service using =company-mode=

#+BEGIN_SRC emacs-lisp
 (use-package company
   :ensure t
   :config (global-company-mode t))
#+END_SRC

=Flycheck= to allow for the checking of code

#+BEGIN_SRC emacs-lisp
 (use-package flycheck
   ;; :diminish flycheck-mode
   :demand t
   :ensure t
   :init
   (setq flycheck-check-syntax-automatically '(mode-enabled save))
   (setq flycheck-checker-error-threshold 2000)
   :config
   (mapc (lambda (mode)
           (add-hook mode 'flycheck-mode))
         '(elm-mode-hook
           emacs-lisp-mode-hook
           haskell-mode-hook
           ))
   (add-hook 'sh-mode-hook
             (lambda ()
               (flycheck-select-checker 'sh-shellcheck)))
   (add-hook 'elm-mode-hook
             (lambda ()
               (flycheck-elm-setup))))
#+END_SRC


Project management using projectile

#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :ensure t
    :bind-keymap (("C-c p" . projectile-command-map))
    :config
    (projectile-global-mode)
    (setq projectile-enable-caching t))
#+END_SRC


Snippet support

#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :ensure t
    :config
    (use-package yasnippet-snippets
      :ensure t)
    (yas-reload-all))

  (add-hook 'prog-mode-hook 'yas-minor-mode)
#+END_SRC

Highlight TODO / FIXME strings in buffers

#+BEGIN_SRC emacs-lisp
 (use-package fic-mode
   :ensure t
   :config
   (add-hook 'prog-mode-hook 'fic-mode))
#+END_SRC

*** Dumb-jump

#+BEGIN_SRC emacs-lisp
    (use-package dumb-jump
      :ensure t
      ;; :bind (("M-g o" . dumb-jump-go-other-window)
      ;;        ("M-g j" . dumb-jump-go)
      ;;        ("M-g x" . dumb-jump-go-prefer-external)
      ;;        ("M-g z" . dumb-jump-go-prefer-external-other-window))
      :init
      (dumb-jump-mode)
      :config
      (setq dumb-jump-selector 'ivy)
      ;; Add some config for elm files
      (nconc dumb-jump-language-file-exts
             '((:language "elm" :ext "elm" :agtype "elm" :rgtype "elm")))
      (nconc dumb-jump-language-comments
             '((:comment "--" :language "elm")))
      (nconc dumb-jump-find-rules
             ;; Rules, based off the haskell syntax
             '((:type "module" :supports ("ag" "rg") :language "elm"
                      :regex "^module\\s+JJJ\\s+"
                      :tests ("model Test exposing (exportA, exportB)"))

               (:type "type" :supports ("ag" "rg" "grep" "git-grep") :language "elm"
                      :regex "^type\\s+JJJ\\b"
                      :tests ("type Test"))
               (:type "type" :supports ("ag" "rg" "grep" "git-grep") :language "elm"
                      :regex "^type\\s+alias\\s+JJJ\\b"
                      :tests ("type alias Test" "type alias Model ="))
               (:type "function" :supports ("ag" "rg" "grep" "git-grep") :language "elm"
                      :regex "^port\\s+JJJ\\b\\s*:[^:]"
                      :tests ("port requestPopup :"))
               (:type "function" :supports ("ag" "rg" "grep" "git-grep") :language "elm"
                      :regex "^\\s*JJJ\\s*:[^:].*->.*"
                      :tests ("foo : Int -> Int"))
               ))
      ;;--regex-Elm=/^ *([[:lower:]][[:alnum:]_]+)[[:blank:]]*:[^:][^-]+$/\1/c,constant,constants/
      )
#+END_SRC

** Javascript and friends

Some additional modes for Javascript (rubbish language)

#+BEGIN_SRC emacs-lisp
  (use-package coffee-mode
      :ensure t
      :defer t
      :mode "\\.coffee\\'")
#+END_SRC

Highlighting for pug/jade templates

#+BEGIN_SRC emacs-lisp
  (use-package pug-mode
    :ensure t
    :defer t
    :mode ("\\.pug\\'" "\\.jade\\'")
    :config
    (setq pug-tab-width 4))
#+END_SRC

** Elm

Allow for the searching of locally installed Elm binaries, perhaps in
the horrble `node_modules`.

#+BEGIN_SRC emacs-lisp
  (defun bin-from-node-modules (variable executable)
    (let ((root (locate-dominating-file
                 (or (buffer-file-name) default-directory)
                 (lambda (dir)
                   (let ((target (expand-file-name (concat "node_modules/.bin/" executable) dir)))
                     (and target (file-executable-p target)))))))
      (when root
        (let ((target (expand-file-name (concat "node_modules/.bin/" executable) root)))
          ;;(message "Setting value %s to vraible %s" target variable)
          (set variable target)))))

  (defun switch-elm-version ()
    (message "Running 'switch-elm-version'")
    (let ((root (locate-dominating-file
                (or (buffer-file-name) default-directory)
                "elm.json")))
      (when root
        (message "Setting local values for elm-mode")
        (setq elm-interactive-command '("elm" "repl"))
        (setq elm-reactor-command '("elm" "reactor"))
        (setq elm-reactor-arguments '("--port" "8000"))
        (setq elm-compile-command '("elm" "make"))
        (setq elm-compile-arguments '("--output=elm.js" "--debug"))
        (setq elm-package-command '("elm" "install"))
        (setq elm-package-json "elm.json")
        (setq elm-format-elm-version "0.19"))))
#+END_SRC

Add =elm-mode= and =flycheck= configuration for editing of elm
buffers.

#+BEGIN_SRC emacs-lisp
  (use-package elm-mode
    :ensure t
    :defer t
    :mode "\\.elm\\'"
    :init
    (add-to-list 'company-backends 'company-elm)
    (add-hook 'elm-mode #'elm-oracle-setup-completion)
    (add-hook 'elm-mode 'global-company-mode)
    :config
    (company-mode)
    (setq elm-format-on-save t)
    (add-hook 'after-init-hook #'global-flycheck-mode)
    (add-hook 'elm-mode-hook #'switch-elm-version))

  (use-package flycheck-elm
    :ensure t
    :config
    (with-eval-after-load 'flycheck
      '(add-hook 'flycheck-mode-hook #'flycheck-elm-setup)))
#+END_SRC

** Haskell

Some _very_ basic Haskell config

#+BEGIN_SRC emacs-lisp
  (defun fix-imports ()
    "Fixes imports."
    (interactive)
    (sort-lines nil (region-beginning) (region-end))
    (align-regexp (region-beginning) (region-end) "\\(\\s-*\\)#-"))

  (use-package haskell-mode
    :ensure t
    :defer t
    :mode "\\.hs\\'")
#+END_SRC

** Polymode

Define polymode to allow multiple modes in a single buffer. Handy for
=knitr= and friends

#+BEGIN_SRC emacs-lisp
  (use-package polymode
    :ensure t
    :mode
    ("\\.Rnw" . poly-noweb+r-mode))
#+END_SRC
** LaTeX

Setup AUCTex for some nice LaTeX support in emacs. This workflow is
centered around using =latexmk= as the build tool and that the LaTeX
project is version controlled in git.

From the project specific =.latexmkrc= we can then determine relative
pathing for files to correctly allow for the automatic setting of the
=TeX-master= variable, removing the need to spoil the source files
themselves with local config comment strings.

#+BEGIN_SRC emacs-lisp
  (defun extract-default-files ()
    "Extract latex project main file."
    (let* ((default-directory (locate-dominating-file "." "Makefile"))
           (target-file (concat default-directory "Makefile")))
      (with-current-buffer (find-file-noselect target-file)
        (save-excursion ;; Don't change location of point.
          (goto-char (point-min)) ;; From the beginning...
          (when (re-search-forward "MAINFILE\s+:=\s+\\(.*\\)\s*")
            (concat default-directory (match-string 1))))
        )))

  ;; https://www.emacswiki.org/emacs/AUCTeX
  ;; Automagic detection of master file
  ;; (defun guess-TeX-master (filename)
  ;;   "Guess the master file for FILENAME from currently open .tex files."
  ;;   (let ((candidate nil)
  ;;         (filename (file-name-nondirectory filename)))
  ;;     (message "riunning the guess tex master function")
  ;;     (save-excursion
  ;;       (dolist (buffer (buffer-list))
  ;;         (with-current-buffer buffer
  ;;           (let ((name (buffer-name))
  ;;                 (file buffer-file-name))
  ;;             (if (and file (string-match "\\.tex$" file))
  ;;                 (progn
  ;;                   (goto-char (point-min))
  ;;                   (if (re-search-forward (concat "\\\\input{" filename "}") nil t)
  ;;                       (setq candidate file))
  ;;                   (if (re-search-forward (concat "\\\\include{" (file-name-sans-extension filename) "}") nil t)
  ;;                       (setq candidate file))))))))
  ;;     (if candidate
  ;;         (message "TeX master document: %s" (file-name-nondirectory candidate)))
  ;;     candidate))

  (defun relative-master (path)
    "Determine the relative path to the master file, calcuated by extract-default-files."
    (let ((master-file (extract-default-files)))
      (f-relative master-file (f-dirname path))))

  (defun reload-after-TeX-complete (process msg)
    "Reload any associated PDFView buffers, after compilation succeeds."
    (TeX-command-sentinel process msg)
    ;; Now update the produced synctex file to cater for the case of Sweave/knitr interactions
    (dolist ($buf (buffer-list (current-buffer)))
      (with-current-buffer $buf
        (when (eq (buffer-local-value 'major-mode $buf) 'pdf-view-mode)
          (message "Reloading PDF: %s" (buffer-name $buf))
          (revert-buffer t t))))
    )

  (defun latex-make-on-save ()
    "Run make on the project makefile, reloading pdf-view-mode buffers."
    (interactive)
    (message "runnning save command")
    (let ((TeX-save-query nil)
          (TeX-process-asynchronous t)
          (TeX-error-overview-open-after-TeX-run t)
          (master-file (TeX-master-file))
          (process (TeX-command-menu "Make")))
      ;;(TeX-save-document "")
      ;;(TeX-command-menu "Make")
      (set-process-sentinel process 'reload-after-TeX-complete)))

  ;; (defun TeX-texify-sentinel (&optional proc sentinel)
  ;;   "Non-interactive! Call the standard-sentinel of the current LaTeX-process.
  ;; If there is still something left do do start the next latex-command."
  ;;   (set-buffer (process-buffer proc))
  ;;   (funcall TeX-texify-sentinel proc sentinel)
  ;;   (let ((case-fold-search nil))
  ;;     (when (string-match "\\(finished\\|exited\\)" sentinel)
  ;;       (set-buffer TeX-command-buffer)
  ;;       (unless (plist-get TeX-error-report-switches (intern (TeX-master-file)))
  ;;         (TeX-texify)))))

  ;; (defun TeX-texify ()
  ;;   "Get everything done."
  ;;   (interactive)
  ;;   (let ((nextCmd (TeX-command-default (TeX-master-file)))
  ;;         proc)
  ;;     (if (and (null TeX-texify-Show)
  ;;              (equal nextCmd TeX-command-Show))
  ;;         (when  (called-interactively-p 'any)
  ;;           (message "TeX-texify: Nothing to be done."))
  ;;       (TeX-command nextCmd 'TeX-master-file)
  ;;       (when (or (called-interactively-p 'any)
  ;;                 (null (boundp 'TeX-texify-count-same-command))
  ;;                 (null (boundp 'TeX-texify-last-command))
  ;;                 (null (equal nextCmd TeX-texify-last-command)))
  ;;         (mapc 'make-local-variable '(TeX-texify-sentinel TeX-texify-count-same-command TeX-texify-last-command))
  ;;         (setq TeX-texify-count-same-command 1))
  ;;       (if (>= TeX-texify-count-same-command TeX-texify-max-runs-same-command)
  ;;           (message "TeX-texify: Did %S already %d times. Don't want to do it anymore." TeX-texify-last-command TeX-texify-count-same-command)
  ;;         (setq TeX-texify-count-same-command (1+ TeX-texify-count-same-command))
  ;;         (setq TeX-texify-last-command nextCmd)
  ;;         (and (null (equal nextCmd TeX-command-Show))
  ;;              (setq proc (get-buffer-process (current-buffer)))
  ;;              (setq TeX-texify-sentinel (process-sentinel proc))
  ;;              (set-process-sentinel proc 'TeX-texify-sentinel))))))

  (use-package tex
    :ensure auctex
    :mode (("\\.tex\\'" . LaTeX-mode))
    :commands (latex-mode LaTeX-mode plain-tex-mode)
    :init
    (add-hook 'LaTeX-mode-hook 'LaTeX-preview-setup)
    (add-hook 'LaTeX-mode-hook 'flyspell-mode)
    (add-hook 'LaTeX-mode-hook 'turn-on-reftex)
    (add-hook 'latex-mode-hook 'turn-on-reftex)
    (add-hook 'LaTeX-mode-hook 'LaTeX-math-mode)
    (add-hook 'LaTeX-mode-hook 'visual-line-mode)
    (add-hook 'LaTeX-mode-hook '(lambda ()
                                  (setq TeX-master (relative-master (buffer-file-name)))))
    (add-hook 'LaTeX-mode-hook (lambda ()
                                 (add-to-list 'TeX-command-list '("Make" "make" TeX-run-TeX nil t))
                                 (add-hook 'after-save-hook 'latex-make-on-save nil t))))
    ;; (TeX-add-style-hook "natbib"
    ;;     (lambda ()
    ;;       (if (fboundp 'reftex-set-cite-format)
    ;;           (reftex-set-cite-format 'natbib))))
    :config
    (setq TeX-auto-save t)
    (setq TeX-parse-self t)
    (setq TeX-save-query nil)
    (setq TeX-PDF-mode t)
    (setq reftex-plug-into-AUCTeX t)
    (setq reftex-use-external-file-finders t)
    (setq LaTeX-csquotes-close-quote "}")
    (setq LaTeX-csquotes-open-quote "\\enquote{")
    ;; Make reftex try play nicer with biblatex
    (setq reftex-bibliography-commands '("bibliography" "nobibliography" "addbibresource"))
    (setq reftex-cite-format 'natbib)
#+END_SRC

Now add =pdf-tools= for nicer PDF interactions

#+BEGIN_SRC emacs-lisp
  (use-package pdf-tools
    :ensure t
    :defer t
    :magic ("%PDF" . pdf-view-mode)
    :config
    ;; initialise
    (pdf-tools-install)
    ;; open pdfs scaled to fit page
    (setq-default pdf-view-display-size 'fit-page)
    ;; automatically annotate highlights
    (setq pdf-annot-activate-created-annotations t)
    ;; use normal isearch
    (define-key pdf-view-mode-map (kbd "C-s") 'isearch-forward))
#+END_SRC

** R

#+BEGIN_SRC emacs-lisp
  (use-package poly-R
    :ensure t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package ess
    :ensure t
    :init (require 'ess-site))
#+END_SRC

** Scala

Use =scala-mode= for scala syntax highlighting

#+BEGIN_SRC emacs-lisp
(use-package scala-mode
  :ensure t
  :defer t
  :mode "\\.scala\\'")
#+END_SRC

** Nix and nixpkg

#+BEGIN_SRC emacs-lisp
  (use-package nix-mode
    :ensure t
    :defer t
    :mode "\\.nix\\'")

#+END_SRC
** Terminal
 #+BEGIN_SRC emacs-lisp
   (defvar my-term-shell "/usr/local/bin/fish")
   (defadvice ansi-term (before force-bash)
     (interactive (list my-term-shell)))
   (ad-activate 'ansi-term)

   ;;(global-set-key (kbd "<M-return>") 'ansi-term)
 #+END_SRC
* Org
** Appearance

Improve the appearance of bullet points in Emacs:

#+BEGIN_SRC emacs-lisp
  (use-package org-bullets
    :config
    (setq org-bullets-bullet-list '("∙"))
    (add-hook 'org-mode-hook 'org-bullets-mode))
#+END_SRC

Set colours for priorities

#+BEGIN_SRC emacs-lisp
(setq org-priority-faces '((?A . (:foreground "#F0DFAF" :weight bold))
                           (?B . (:foreground "LightSteelBlue"))
                           (?C . (:foreground "OliveDrab"))))
#+END_SRC

** Keybinds

Define org-mode related keybinds:

#+BEGIN_SRC emacs-lisp
  (define-key global-map (kbd "C-c l") 'org-store-link)
  (define-key global-map (kbd "C-c a") 'org-agenda)
  (define-key global-map (kbd "C-c c") 'org-capture)
  (setq org-log-done t)
#+END_SRC

** File locations

Define the locations of the different org files:

#+BEGIN_SRC emacs-lisp
  (setq org-agenda-files (list "~/org/gtd.org"
                               "~/org/projects.org"
                               "~/org/calendar.org"
                               "~/org/call.org"))
#+END_SRC

Nicer indenting in =org-mode= files

#+BEGIN_SRC emacs-lisp
  (add-hook 'org-mode-hook 'org-indent-mode)
#+END_SRC

** Alerts

Add =org-alert= to display some alerts on the desktop

#+BEGIN_SRC emacs-lisp
  (use-package org-alert
    :ensure t
    :config
    (with-system darwin
                 (setq alert-default-style 'message))
    (with-system gnu/linux
                 (setq alert-default-style 'libnotify)))

#+END_SRC

** Capture templates

#+BEGIN_SRC emacs-lisp
  (setq org-capture-templates
        '(("t" "Todo" entry
           (file+headline "~/org/gtd.org" "Tasks")
           "* TODO %?\n  %i\n  %a")
          ("p" "Project Todo" entry
           (file+headline "~/org/projects.org" "Tasks")
           "* TODO %?\n  %i\n  %a")
          ("c" "Call someone" entry
           (file+headline "~/org/call.org" "To call")
           "* TODO %?\n  %i\n")
          ))
#+END_SRC

** Google calendar integration

#+BEGIN_SRC emacs-lisp
  (defvar org-gcal-last-synced nil
    "The last time a org-gcal-sync was run")

  (use-package org-gcal
    :ensure t
    :config
    (setq org-gcal-file-alist '(("gpampara@gmail.com" . "~/org/calendar.org")))

    (if org-gcal-last-synced
        (unless (string-equal 'org-gcal-last-synced (format-time-string "%Y-%m-%d"))
          (org-gcal-sync)
          (setq org-gcal-last-synced (format-time-string"%Y-%m-%d")))))

  ;;      (setq org-gcal-last-synced (format-time-string "%Y-%m-%d"))))

      ;; Create a timer to run the gcal-hook periodically for us, every hour
      ;;(run-at-time t 3600 'org-gcal-sync))
      ;(add-hook 'org-agenda-mode-hook (lambda () (org-gcal-sync)))
      ;(add-hook 'org-capture-after-finalize-hook (lambda () (org-gcal-sync))))

#+END_SRC

* Extras
** Writing

Upgrade the dictionary used to a more up-to-date, recent version.

#+BEGIN_SRC emacs-lisp
  (cond
   ;; try hunspell at first
   ;; if hunspell does NOT exist, use aspell
   ((executable-find "hunspell")
    (setq ispell-program-name "hunspell")
    (setq ispell-local-dictionary "en_US")
    (setq ispell-local-dictionary-alist
          ;; Please note the list `("-d" "en_US")` contains ACTUAL parameters passed to hunspell
          ;; You could use `("-d" "en_US,en_US-med")` to check with multiple dictionaries
          '(("en_US" "[[:alpha:]]" "[^[:alpha:]]" "[']" nil ("-d" "en_US") nil utf-8)
            )))

   ((executable-find "aspell")
    (setq ispell-program-name "aspell")
    ;; Please note ispell-extra-args contains ACTUAL parameters passed to aspell
    (setq ispell-extra-args '("--sug-mode=ultra" "--lang=en_US"))))
#+END_SRC

=writegood-mode= highlights bad words, weasels etc. Also has functions
to calculate readability of writing.

#+BEGIN_SRC emacs-lisp
  (use-package writegood-mode
    :bind ("C-c g" . writegood-mode)
    :init
    (add-hook 'TeX-update-style-hook #'writegood-mode)
    :config
    (add-to-list 'writegood-weasel-words "actionable"))
#+END_SRC

Add =langtool= as an additional tool to use

#+BEGIN_SRC emacs-lisp
  (use-package langtool
    :ensure t
    :config (setq langtool-language-tool-jar "/usr/local/Cellar/languagetool/4.3/libexec/languagetool-commandline.jar"))
#+END_SRC
